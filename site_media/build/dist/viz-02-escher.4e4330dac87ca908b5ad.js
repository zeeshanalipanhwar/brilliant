(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[210],{1e3:function(e,t,n){"use strict";(function(){"use strict";var a=this||{};var r="function"!=="undefined";var s=a.THREE||r&&n(773);if(!s)throw new Error("MeshLine requires three.js");function i(){this.positions=[];this.previous=[];this.next=[];this.side=[];this.width=[];this.indices_array=[];this.uvs=[];this.counters=[];this.geometry=new s.BufferGeometry;this.widthCallback=null}i.prototype.setGeometry=function(e,t){this.widthCallback=t;this.positions=[];this.counters=[];if(e instanceof s.Geometry){for(var n=0;n<e.vertices.length;n++){var a=e.vertices[n];var t=n/e.vertices.length;this.positions.push(a.x,a.y,a.z);this.positions.push(a.x,a.y,a.z);this.counters.push(t);this.counters.push(t)}}if(e instanceof s.BufferGeometry){}if(e instanceof Float32Array||e instanceof Array){for(var n=0;n<e.length;n+=3){var t=n/e.length;this.positions.push(e[n],e[n+1],e[n+2]);this.positions.push(e[n],e[n+1],e[n+2]);this.counters.push(t);this.counters.push(t)}}this.process()};i.prototype.compareV3=function(e,t){var n=e*6;var a=t*6;return this.positions[n]===this.positions[a]&&this.positions[n+1]===this.positions[a+1]&&this.positions[n+2]===this.positions[a+2]};i.prototype.copyV3=function(e){var t=e*6;return[this.positions[t],this.positions[t+1],this.positions[t+2]]};i.prototype.process=function(){var e=this.positions.length/6;this.previous=[];this.next=[];this.side=[];this.width=[];this.indices_array=[];this.uvs=[];for(var t=0;t<e;t++){this.side.push(1);this.side.push(-1)}var n;for(var t=0;t<e;t++){if(this.widthCallback)n=this.widthCallback(t/(e-1));else n=1;this.width.push(n);this.width.push(n)}for(var t=0;t<e;t++){this.uvs.push(t/(e-1),0);this.uvs.push(t/(e-1),1)}var a;if(this.compareV3(0,e-1)){a=this.copyV3(e-2)}else{a=this.copyV3(0)}this.previous.push(a[0],a[1],a[2]);this.previous.push(a[0],a[1],a[2]);for(var t=0;t<e-1;t++){a=this.copyV3(t);this.previous.push(a[0],a[1],a[2]);this.previous.push(a[0],a[1],a[2])}for(var t=1;t<e;t++){a=this.copyV3(t);this.next.push(a[0],a[1],a[2]);this.next.push(a[0],a[1],a[2])}if(this.compareV3(e-1,0)){a=this.copyV3(1)}else{a=this.copyV3(e-1)}this.next.push(a[0],a[1],a[2]);this.next.push(a[0],a[1],a[2]);for(var t=0;t<e-1;t++){var r=t*2;this.indices_array.push(r,r+1,r+2);this.indices_array.push(r+2,r+1,r+3)}if(!this.attributes){this.attributes={position:new s.BufferAttribute(new Float32Array(this.positions),3),previous:new s.BufferAttribute(new Float32Array(this.previous),3),next:new s.BufferAttribute(new Float32Array(this.next),3),side:new s.BufferAttribute(new Float32Array(this.side),1),width:new s.BufferAttribute(new Float32Array(this.width),1),uv:new s.BufferAttribute(new Float32Array(this.uvs),2),index:new s.BufferAttribute(new Uint16Array(this.indices_array),1),counters:new s.BufferAttribute(new Float32Array(this.counters),1)}}else{this.attributes.position.copyArray(new Float32Array(this.positions));this.attributes.position.needsUpdate=true;this.attributes.previous.copyArray(new Float32Array(this.previous));this.attributes.previous.needsUpdate=true;this.attributes.next.copyArray(new Float32Array(this.next));this.attributes.next.needsUpdate=true;this.attributes.side.copyArray(new Float32Array(this.side));this.attributes.side.needsUpdate=true;this.attributes.width.copyArray(new Float32Array(this.width));this.attributes.width.needsUpdate=true;this.attributes.uv.copyArray(new Float32Array(this.uvs));this.attributes.uv.needsUpdate=true;this.attributes.index.copyArray(new Uint16Array(this.indices_array));this.attributes.index.needsUpdate=true}this.geometry.addAttribute("position",this.attributes.position);this.geometry.addAttribute("previous",this.attributes.previous);this.geometry.addAttribute("next",this.attributes.next);this.geometry.addAttribute("side",this.attributes.side);this.geometry.addAttribute("width",this.attributes.width);this.geometry.addAttribute("uv",this.attributes.uv);this.geometry.addAttribute("counters",this.attributes.counters);this.geometry.setIndex(this.attributes.index)};function o(e,t,n,a,r){var s;e=e.subarray||e.slice?e:e.buffer;n=n.subarray||n.slice?n:n.buffer;e=t?e.subarray?e.subarray(t,r&&t+r):e.slice(t,r&&t+r):e;if(n.set){n.set(e,a)}else{for(s=0;s<e.length;s++){n[s+a]=e[s]}}return n}i.prototype.advance=function(e){var t=this.attributes.position.array;var n=this.attributes.previous.array;var a=this.attributes.next.array;var r=t.length;o(t,0,n,0,r);o(t,6,t,0,r-6);t[r-6]=e.x;t[r-5]=e.y;t[r-4]=e.z;t[r-3]=e.x;t[r-2]=e.y;t[r-1]=e.z;o(t,6,a,0,r-6);a[r-6]=e.x;a[r-5]=e.y;a[r-4]=e.z;a[r-3]=e.x;a[r-2]=e.y;a[r-1]=e.z;this.attributes.position.needsUpdate=true;this.attributes.previous.needsUpdate=true;this.attributes.next.needsUpdate=true};function u(e){var t=["precision highp float;","","attribute vec3 position;","attribute vec3 previous;","attribute vec3 next;","attribute float side;","attribute float width;","attribute vec2 uv;","attribute float counters;","","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","uniform vec2 resolution;","uniform float lineWidth;","uniform vec3 color;","uniform float opacity;","uniform float near;","uniform float far;","uniform float sizeAttenuation;","","varying vec2 vUV;","varying vec4 vColor;","varying float vCounters;","","vec2 fix( vec4 i, float aspect ) {","","    vec2 res = i.xy / i.w;","    res.x *= aspect;","\t vCounters = counters;","    return res;","","}","","void main() {","","    float aspect = resolution.x / resolution.y;","\t float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);","","    vColor = vec4( color, opacity );","    vUV = uv;","","    mat4 m = projectionMatrix * modelViewMatrix;","    vec4 finalPosition = m * vec4( position, 1.0 );","    vec4 prevPos = m * vec4( previous, 1.0 );","    vec4 nextPos = m * vec4( next, 1.0 );","","    vec2 currentP = fix( finalPosition, aspect );","    vec2 prevP = fix( prevPos, aspect );","    vec2 nextP = fix( nextPos, aspect );","","\t float pixelWidth = finalPosition.w * pixelWidthRatio;","    float w = 1.8 * pixelWidth * lineWidth * width;","","    if( sizeAttenuation == 1. ) {","        w = 1.8 * lineWidth * width;","    }","","    vec2 dir;","    if( next == position ) dir = normalize( currentP - prevP );","    else if( previous == position ) dir = normalize( nextP - currentP );","    else {","        vec2 dir1 = normalize( currentP - prevP );","        vec2 dir2 = normalize( nextP - currentP );","        dir = normalize( dir1 + dir2 );","","        vec2 perp = vec2( -dir1.y, dir1.x );","        vec2 miter = vec2( -dir.y, dir.x );","        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );","","    }","","    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;","    vec2 normal = vec2( -dir.y, dir.x );","    normal.x /= aspect;","    normal *= .5 * w;","","    vec4 offset = vec4( normal * side, 0.0, 1.0 );","    finalPosition.xy += offset.xy;","","    gl_Position = finalPosition;","","}"];var n=["#extension GL_OES_standard_derivatives : enable","precision mediump float;","","uniform sampler2D map;","uniform sampler2D alphaMap;","uniform float useMap;","uniform float useAlphaMap;","uniform float useDash;","uniform float dashArray;","uniform float dashOffset;","uniform float dashRatio;","uniform float visibility;","uniform float alphaTest;","uniform vec2 repeat;","","varying vec2 vUV;","varying vec4 vColor;","varying float vCounters;","","void main() {","","    vec4 c = vColor;","    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );","    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;","    if( c.a < alphaTest ) discard;","    if( useDash == 1. ){","        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));","    }","    gl_FragColor = c;","    gl_FragColor.a *= step(vCounters, visibility);","}"];function a(e,t){if(e===undefined)return t;return e}s.Material.call(this);e=e||{};this.lineWidth=a(e.lineWidth,1);this.map=a(e.map,null);this.useMap=a(e.useMap,0);this.alphaMap=a(e.alphaMap,null);this.useAlphaMap=a(e.useAlphaMap,0);this.color=a(e.color,new s.Color(16777215));this.opacity=a(e.opacity,1);this.resolution=a(e.resolution,new s.Vector2(1,1));this.sizeAttenuation=a(e.sizeAttenuation,1);this.near=a(e.near,1);this.far=a(e.far,1);this.dashArray=a(e.dashArray,0);this.dashOffset=a(e.dashOffset,0);this.dashRatio=a(e.dashRatio,.5);this.useDash=this.dashArray!==0?1:0;this.visibility=a(e.visibility,1);this.alphaTest=a(e.alphaTest,0);this.repeat=a(e.repeat,new s.Vector2(1,1));var r=new s.RawShaderMaterial({uniforms:{lineWidth:{type:"f",value:this.lineWidth},map:{type:"t",value:this.map},useMap:{type:"f",value:this.useMap},alphaMap:{type:"t",value:this.alphaMap},useAlphaMap:{type:"f",value:this.useAlphaMap},color:{type:"c",value:this.color},opacity:{type:"f",value:this.opacity},resolution:{type:"v2",value:this.resolution},sizeAttenuation:{type:"f",value:this.sizeAttenuation},near:{type:"f",value:this.near},far:{type:"f",value:this.far},dashArray:{type:"f",value:this.dashArray},dashOffset:{type:"f",value:this.dashOffset},dashRatio:{type:"f",value:this.dashRatio},useDash:{type:"f",value:this.useDash},visibility:{type:"f",value:this.visibility},alphaTest:{type:"f",value:this.alphaTest},repeat:{type:"v2",value:this.repeat}},vertexShader:t.join("\r\n"),fragmentShader:n.join("\r\n")});delete e.lineWidth;delete e.map;delete e.useMap;delete e.alphaMap;delete e.useAlphaMap;delete e.color;delete e.opacity;delete e.resolution;delete e.sizeAttenuation;delete e.near;delete e.far;delete e.dashArray;delete e.dashOffset;delete e.dashRatio;delete e.visibility;delete e.alphaTest;delete e.repeat;r.type="MeshLineMaterial";r.setValues(e);return r}u.prototype=Object.create(s.Material.prototype);u.prototype.constructor=u;u.prototype.copy=function(e){s.Material.prototype.copy.call(this,e);this.lineWidth=e.lineWidth;this.map=e.map;this.useMap=e.useMap;this.alphaMap=e.alphaMap;this.useAlphaMap=e.useAlphaMap;this.color.copy(e.color);this.opacity=e.opacity;this.resolution.copy(e.resolution);this.sizeAttenuation=e.sizeAttenuation;this.near=e.near;this.far=e.far;this.dashArray.copy(e.dashArray);this.dashOffset.copy(e.dashOffset);this.dashRatio.copy(e.dashRatio);this.useDash=e.useDash;this.visibility=e.visibility;this.alphaTest=e.alphaTest;this.repeat.copy(e.repeat);return this};if(true){if(true&&e.exports){t=e.exports={MeshLine:i,MeshLineMaterial:u}}t.MeshLine=i;t.MeshLineMaterial=u}else{}}).call(void 0)},1765:function(e,t){e.exports="//********************************************************************\n//\n// Global defines\n//\n//********************************************************************\n\n// Infinity\n#define AUTO_INFINITY 3.402823e+38\n\n//********************************************************************\n//\n// General functions\n//\n//********************************************************************\n\nmat2 a_outerProduct(in vec2 a, in vec2 b)\n{\n\treturn mat2(a * b.x, a * b.y);\n}\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n\treturn mat3(a * b.x, a * b.y, a * b.z);\n}\n\nmat4 a_outerProduct(in vec4 a, in vec4 b)\n{\n\treturn mat4(a * b.x, a * b.y, a * b.z, a * b.w);\n}\n\n\n//********************************************************************\n//\n// Scalar overloads\n//\n//********************************************************************\n\nfloat neg(in float a)\n{\n\treturn -a;\n}\n\nfloat add(in float a, in float b)\n{\n\treturn a+b;\n}\n\nfloat sub(in float a, in float b)\n{\n\treturn a-b;\n}\n\nfloat mult(in float a, in float b)\n{\n\treturn a*b;\n}\n\nfloat div(float a, in float b)\n{\n\treturn a/b;\n}\n\nfloat a_sin(in float a)\n{\n\treturn sin(a);\n}\n\nfloat a_cos(in float a)\n{\n\treturn cos(a);\n}\n\nfloat a_exp(in float a)\n{\n\treturn exp(a);\n}\n\nfloat a_log(in float a)\n{\n\treturn log(a);\n}\n\nfloat a_pow(in float a, in float k)\n{\n\treturn consistentPow(a, k);\n}\nfloat a_abs(in float a)\n{\n\treturn abs(a);\n}\n\nfloat a_sqrt(in float a)\n{\n\treturn safeSqrt(a);\n}\n\n\n//********************************************************************\n//\n// Data structure for holding information for 2D Gradient calculation.\n//\n//********************************************************************\n\nstruct GradNum2\n{\n\tfloat val;\n\tvec2 g;\n};\n\n//********************************************************************\n//\n// Data structure for holding information for 3D Gradient calculation\n//\n//********************************************************************\n\nstruct GradNum3\n{\n\tfloat val;\n\tvec3 g;\n};\n\n//********************************************************************\n//\n// Data structure for holding information for 4D Gradient calculation\n//\n//********************************************************************\n\nstruct GradNum4\n{\n\tfloat val;\n\tvec4 g;\n};\n\n//********************************************************************\n//\n// Data structure for holding information for 2D Hessian calculation. Gradient is also included\n//\n//********************************************************************\n\n\nstruct HessNum2\n{\n\tfloat val;\n\tvec2 g;\n\tmat2 h;\n};\n\n//********************************************************************\n//\n// Data structure for holding information for 3D Hessian calculation. Gradient is also included\n//\n//********************************************************************\n\n\nstruct HessNum3\n{\n\tfloat val;\n\tvec3 g;\n\tmat3 h;\n};\n\n//********************************************************************\n//\n// Data structure for holding information for 4D Hessian calculation. Gradient is also included\n//\n//********************************************************************\n\n\nstruct HessNum4\n{\n\tfloat val;\n\tvec4 g;\n\tmat4 h;\n};\n\n\n\n\n//********************************************************************\n//\n// 2D Gradient functions\n//\n//********************************************************************\n\n\nGradNum2 a_constG2(in float val)\n{\n\treturn GradNum2(val, vec2(0.));\n}\n\nGradNum2 neg(in GradNum2 a)\n{\n\treturn GradNum2(-a.val,-a.g);\n}\n\nGradNum2 add(in GradNum2 a, in GradNum2 b)\n{\n\treturn GradNum2(a.val + b.val, a.g + b.g);\n}\n\nGradNum2 add(in GradNum2 a, in float b)\n{\n\treturn GradNum2(a.val + b, a.g);\n}\n\nGradNum2 add(in float a, in GradNum2 b)\n{\n\treturn GradNum2(b.val + a, b.g);\n}\n\nGradNum2 sub(in GradNum2 a, in GradNum2 b)\n{\n\treturn GradNum2(a.val - b.val, a.g - b.g);\n}\n\nGradNum2 sub(in GradNum2 a, in float b)\n{\n\treturn GradNum2(a.val - b, a.g);\n}\n\nGradNum2 sub(in float a, in GradNum2 b)\n{\n\treturn GradNum2(a - b.val, -b.g);\n}\n\nGradNum2 mult(in GradNum2 a, in GradNum2 b)\n{\n\treturn GradNum2(a.val * b.val, b.val*a.g + a.val*b.g);\n}\n\nGradNum2 mult(in GradNum2 a, float b)\n{\n\treturn GradNum2(a.val*b, a.g*b);\n}\n\nGradNum2 mult(in float a, in GradNum2 b)\n{\n\treturn GradNum2(b.val*a, b.g*a);\n}\n\nGradNum2 div(in GradNum2 a, in GradNum2 b)\n{\n\tGradNum2 r = GradNum2(a.val / b.val, a.g);\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g / b.val;\n\treturn r;\n}\n\nGradNum2 div(in GradNum2 a, float b)\n{\n\treturn GradNum2(a.val/b, a.g/b);\n}\n\nGradNum2 div(float a, in GradNum2 b)\n{\n\treturn div(a_constG2(a), b);\n}\n\nGradNum2 a_sin(in GradNum2 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn GradNum2(s , c * a.g);\n}\n\nGradNum2 a_cos(in GradNum2 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn GradNum2(c , -s * a.g);\n}\n\nGradNum2 a_exp(in GradNum2 a)\n{\n\tfloat e = exp(a.val);\n\treturn GradNum2(e , e * a.g);\n}\n\nGradNum2 a_log(in GradNum2 a)\n{\n\tfloat ai = 1./a.val;\n\treturn GradNum2(log(a.val) , ai * a.g);\n}\n\nGradNum2 a_pow(in GradNum2 a, float k)\n{\n\tfloat ap = k*consistentPow(a.val,k-1.);\n\treturn GradNum2(consistentPow(a.val,k) , ap * a.g);\n}\n\nGradNum2 a_pow(in GradNum2 a, in GradNum2 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nGradNum2 a_pow(float a, in GradNum2 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nGradNum2 a_abs(in GradNum2 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\treturn GradNum2(l , lp * a.g);\n}\n\nGradNum2 a_sqrt(in GradNum2 a)\n{\n\tfloat as = safeSqrt(a.val);\n\t// float asd = 1. / (2.*as);\n\tfloat asd = 1. / (2.*abs(as));\n\treturn GradNum2(as,a.g*asd);\n}\n\n\n//********************************************************************\n//\n// 3D Gradient functions\n//\n//********************************************************************\n\n\nGradNum3 a_constG3(in float val)\n{\n\treturn GradNum3(val, vec3(0.));\n}\n\nGradNum3 neg(in GradNum3 a)\n{\n\treturn GradNum3(-a.val,-a.g);\n}\n\nGradNum3 add(in GradNum3 a, in GradNum3 b)\n{\n\treturn GradNum3(a.val + b.val, a.g + b.g);\n}\n\nGradNum3 add(in GradNum3 a, in float b)\n{\n\treturn GradNum3(a.val + b, a.g);\n}\n\nGradNum3 add(in float a, in GradNum3 b)\n{\n\treturn GradNum3(b.val + a, b.g);\n}\n\nGradNum3 sub(in GradNum3 a, in GradNum3 b)\n{\n\treturn GradNum3(a.val - b.val, a.g - b.g);\n}\n\nGradNum3 sub(in GradNum3 a, in float b)\n{\n\treturn GradNum3(a.val - b, a.g);\n}\n\nGradNum3 sub(in float a, in GradNum3 b)\n{\n\treturn GradNum3(a - b.val, -b.g);\n}\n\nGradNum3 mult(in GradNum3 a, in GradNum3 b)\n{\n\treturn GradNum3(a.val * b.val, b.val*a.g + a.val*b.g);\n}\n\nGradNum3 mult(in GradNum3 a, float b)\n{\n\treturn GradNum3(a.val*b, a.g*b);\n}\n\nGradNum3 mult(in float a, in GradNum3 b)\n{\n\treturn GradNum3(b.val*a, b.g*a);\n}\n\nGradNum3 div(in GradNum3 a, in GradNum3 b)\n{\n\tGradNum3 r = GradNum3(a.val / b.val, a.g);\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g / b.val;\n\n\treturn r;\n}\n\nGradNum3 div(in GradNum3 a, float b)\n{\n\treturn GradNum3(a.val/b, a.g/b);\n}\n\nGradNum3 div(float a, in GradNum3 b)\n{\n\treturn div(a_constG3(a), b);\n}\n\nGradNum3 a_sin(in GradNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn GradNum3(s , c * a.g);\n}\n\nGradNum3 a_cos(in GradNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn GradNum3(c , -s * a.g);\n}\n\nGradNum3 a_exp(in GradNum3 a)\n{\n\tfloat e = exp(a.val);\n\treturn GradNum3(e , e * a.g);\n}\n\nGradNum3 a_log(in GradNum3 a)\n{\n\tfloat ai = 1./a.val;\n\treturn GradNum3(log(a.val) , ai * a.g);\n}\n\nGradNum3 a_pow(in GradNum3 a, float k)\n{\n\tfloat ap = k*consistentPow(a.val,k-1.);\n\treturn GradNum3(consistentPow(a.val,k) , ap * a.g);\n}\n\nGradNum3 a_pow(in GradNum3 a, in GradNum3 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nGradNum3 a_pow(float a, in GradNum3 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nGradNum3 a_abs(in GradNum3 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\treturn GradNum3(l , lp * a.g);\n}\n\nGradNum3 a_sqrt(in GradNum3 a)\n{\n\tfloat as = safeSqrt(a.val);\n\tfloat asd = 1. / (2.*as);\n\treturn GradNum3(as,a.g*asd);\n}\n\n\n//********************************************************************\n//\n// 4D Gradient functions\n//\n//********************************************************************\n\n\nGradNum4 a_constG4(in float val)\n{\n\treturn GradNum4(val, vec4(0.));\n}\n\nGradNum4 neg(in GradNum4 a)\n{\n\treturn GradNum4(-a.val,-a.g);\n}\n\nGradNum4 add(in GradNum4 a, in GradNum4 b)\n{\n\treturn GradNum4(a.val + b.val, a.g + b.g);\n}\n\nGradNum4 add(in GradNum4 a, in float b)\n{\n\treturn GradNum4(a.val + b, a.g);\n}\n\nGradNum4 add(in float a, in GradNum4 b)\n{\n\treturn GradNum4(b.val + a, b.g);\n}\n\nGradNum4 sub(in GradNum4 a, in GradNum4 b)\n{\n\treturn GradNum4(a.val - b.val, a.g - b.g);\n}\n\nGradNum4 sub(in GradNum4 a, in float b)\n{\n\treturn GradNum4(a.val - b, a.g);\n}\n\nGradNum4 sub(in float a, in GradNum4 b)\n{\n\treturn GradNum4(a - b.val, -b.g);\n}\n\nGradNum4 mult(in GradNum4 a, in GradNum4 b)\n{\n\treturn GradNum4(a.val * b.val, b.val*a.g + a.val*b.g);\n}\n\nGradNum4 mult(in GradNum4 a, float b)\n{\n\treturn GradNum4(a.val*b, a.g*b);\n}\n\nGradNum4 mult(in float a, in GradNum4 b)\n{\n\treturn GradNum4(b.val*a, b.g*a);\n}\n\nGradNum4 div(in GradNum4 a, in GradNum4 b)\n{\n\tGradNum4 r = GradNum4(a.val / b.val, a.g);\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g / b.val;\n\treturn r;\n}\n\nGradNum4 div(in GradNum4 a, float b)\n{\n\treturn GradNum4(a.val/b, a.g/b);\n}\n\nGradNum4 div(float a, in GradNum4 b)\n{\n\treturn div(a_constG4(a), b);\n}\n\nGradNum4 a_sin(in GradNum4 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn GradNum4(s , c * a.g);\n}\n\nGradNum4 a_cos(in GradNum4 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn GradNum4(c , -s * a.g);\n}\n\nGradNum4 a_exp(in GradNum4 a)\n{\n\tfloat e = exp(a.val);\n\treturn GradNum4(e , e * a.g);\n}\n\nGradNum4 a_log(in GradNum4 a)\n{\n\tfloat ai = 1./a.val;\n\treturn GradNum4(log(a.val) , ai * a.g);\n}\n\nGradNum4 a_pow(in GradNum4 a, float k)\n{\n\tfloat ap = k*consistentPow(a.val,k-1.);\n\treturn GradNum4(consistentPow(a.val,k) , ap * a.g);\n}\n\nGradNum4 a_pow(in GradNum4 a, in GradNum4 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nGradNum4 a_pow(float a, in GradNum4 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nGradNum4 a_abs(in GradNum4 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\treturn GradNum4(l , lp * a.g);\n}\n\nGradNum4 a_sqrt(in GradNum4 a)\n{\n\tfloat as = safeSqrt(a.val);\n\tfloat asd = 1. / (2.*as);\n\treturn GradNum4(as,a.g*asd);\n}\n\n\n//********************************************************************\n//\n// 2D Hessian functions\n//\n//********************************************************************\n\n\nHessNum2 a_constH2(in float val)\n{\n\treturn HessNum2(val, vec2(0.), mat2(0.));\n}\n\nHessNum2 neg(in HessNum2 a)\n{\n\treturn HessNum2(-a.val,-a.g,-a.h);\n}\n\nHessNum2 add(in HessNum2 a, in HessNum2 b)\n{\n\treturn HessNum2(a.val + b.val, a.g + b.g, a.h + b.h);\n}\n\nHessNum2 add(in HessNum2 a, in float b)\n{\n\treturn HessNum2(a.val + b, a.g , a.h);\n}\n\nHessNum2 add(in float a, in HessNum2 b)\n{\n\treturn HessNum2(b.val + a, b.g , b.h);\n}\n\nHessNum2 sub(in HessNum2 a, in HessNum2 b)\n{\n\treturn HessNum2(a.val - b.val, a.g - b.g, a.h - b.h);\n}\n\nHessNum2 sub(in HessNum2 a, in float b)\n{\n\treturn HessNum2(a.val - b, a.g , a.h);\n}\n\nHessNum2 sub(in float a, in HessNum2 b)\n{\n\treturn HessNum2(a - b.val, -b.g , -b.h);\n}\n\nHessNum2 mult(in HessNum2 a, in HessNum2 b)\n{\n\treturn HessNum2(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));\n}\n\nHessNum2 mult(in HessNum2 a, float b)\n{\n\treturn HessNum2(a.val*b, a.g*b, a.h*b);\n}\n\nHessNum2 mult(in float a, in HessNum2 b)\n{\n\treturn HessNum2(b.val*a, b.g*a, b.h*a);\n}\n\nHessNum2 div(in HessNum2 a, in HessNum2 b)\n{\n\tHessNum2 r = HessNum2(a.val / b.val, a.g, a.h );\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g / b.val;\n\n\tr.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);\n\tr.h = r.h / b.val;\n\n\treturn r;\n\n}\n\nHessNum2 div(in HessNum2 a, float b)\n{\n\treturn HessNum2(a.val/b, a.g/b, a.h/b);\n}\n\nHessNum2 div(float a, in HessNum2 b) {\n\treturn div(a_constH2(a), b);\n}\n\nHessNum2 a_sin(in HessNum2 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum2(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));\n}\n\nHessNum2 a_cos(in HessNum2 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum2(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));\n}\n\nHessNum2 a_exp(in HessNum2 a)\n{\n\tfloat e = exp(a.val);\n\treturn HessNum2(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));\n}\n\nHessNum2 a_log(in HessNum2 a)\n{\n\tfloat ai = 1./a.val;\n\treturn HessNum2(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));\n}\n\nHessNum2 a_pow(in HessNum2 a, float k)\n{\n\tfloat ap = k*consistentPow(a.val,k-1.);\n\treturn HessNum2(consistentPow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*consistentPow(a.val,k-2.) * a_outerProduct(a.g,a.g));\n}\n\nHessNum2 a_pow(in HessNum2 a, in HessNum2 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nHessNum2 a_pow(float a, in HessNum2 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nHessNum2 a_abs(in HessNum2 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\t// Probably better to always make this 0\n\tfloat lpp = a.val == 0. ? AUTO_INFINITY : 0.;\n\treturn HessNum2(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));\n}\n\nHessNum2 a_sqrt(in HessNum2 a)\n{\n\tfloat as = safeSqrt(a.val);\n\tfloat asd = 1. / (2.*as);\n\tfloat asdd = -1./(4.*pow(a.val,3./2.));\n\treturn HessNum2(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g));\n}\n\n//********************************************************************\n//\n// 3D Hessian functions\n//\n//********************************************************************\n\n\nHessNum3 a_constH3(in float val)\n{\n\treturn HessNum3(val, vec3(0.), mat3(0.));\n}\n\nHessNum3 neg(in HessNum3 a)\n{\n\treturn HessNum3(-a.val,-a.g,-a.h);\n}\n\nHessNum3 add(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val + b.val, a.g + b.g, a.h + b.h);\n}\n\nHessNum3 add(in HessNum3 a, in float b)\n{\n\treturn HessNum3(a.val + b, a.g , a.h);\n}\n\nHessNum3 add(in float a, in HessNum3 b)\n{\n\treturn HessNum3(b.val + a, b.g , b.h);\n}\n\nHessNum3 sub(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val - b.val, a.g - b.g, a.h - b.h);\n}\n\nHessNum3 sub(in HessNum3 a, in float b)\n{\n\treturn HessNum3(a.val - b, a.g , a.h);\n}\n\nHessNum3 sub(in float a, in HessNum3 b)\n{\n\treturn HessNum3(a - b.val, -b.g , -b.h);\n}\n\nHessNum3 mult(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));\n}\n\nHessNum3 mult(in HessNum3 a, float b)\n{\n\treturn HessNum3(a.val*b, a.g*b, a.h*b);\n}\n\nHessNum3 mult(in float a, in HessNum3 b)\n{\n\treturn HessNum3(b.val*a, b.g*a, b.h*a);\n}\n\nHessNum3 div(in HessNum3 a, in HessNum3 b)\n{\n\tHessNum3 r = HessNum3(a.val / b.val, a.g, a.h );\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g / b.val;\n\n\tr.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);\n\tr.h = r.h / b.val;\n\n\treturn r;\n}\n\nHessNum3 div(in HessNum3 a, float b)\n{\n\treturn HessNum3(a.val/b, a.g/b, a.h/b);\n}\n\nHessNum3 div(float a, in HessNum3 b) {\n\treturn div(a_constH3(a), b);\n}\n\nHessNum3 a_sin(in HessNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum3(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));\n}\n\nHessNum3 a_cos(in HessNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum3(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));\n}\n\nHessNum3 a_exp(in HessNum3 a)\n{\n\tfloat e = exp(a.val);\n\treturn HessNum3(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));\n}\n\nHessNum3 a_log(in HessNum3 a)\n{\n\tfloat ai = 1./a.val;\n\treturn HessNum3(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));\n}\n\nHessNum3 a_pow(in HessNum3 a, float k)\n{\n\tfloat ap = k*consistentPow(a.val,k-1.);\n\treturn HessNum3(consistentPow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*consistentPow(a.val,k-2.) * a_outerProduct(a.g,a.g));\n}\n\nHessNum3 a_pow(in HessNum3 a, in HessNum3 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nHessNum3 a_pow(float a, in HessNum3 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nHessNum3 a_abs(in HessNum3 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\t// Probably better to always make this 0\n\tfloat lpp = a.val == 0. ? AUTO_INFINITY : 0.;\n\treturn HessNum3(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));\n}\n\nHessNum3 a_sqrt(in HessNum3 a)\n{\n\tfloat as = safeSqrt(a.val);\n\tfloat asd = 1. / (2.*as);\n\tfloat asdd = -1./(4.*pow(a.val,3./2.));\n\treturn HessNum3(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g));\n}\n\n//********************************************************************\n//\n// 4D Hessian functions\n//\n//********************************************************************\n\n\nHessNum4 a_constH4(in float val)\n{\n\treturn HessNum4(val, vec4(0.), mat4(0.));\n}\n\nHessNum4 neg(in HessNum4 a)\n{\n\treturn HessNum4(-a.val,-a.g,-a.h);\n}\n\nHessNum4 add(in HessNum4 a, in HessNum4 b)\n{\n\treturn HessNum4(a.val + b.val, a.g + b.g, a.h + b.h);\n}\n\nHessNum4 add(in HessNum4 a, in float b)\n{\n\treturn HessNum4(a.val + b, a.g , a.h);\n}\n\nHessNum4 add(in float a, in HessNum4 b)\n{\n\treturn HessNum4(b.val + a, b.g , b.h);\n}\n\nHessNum4 sub(in HessNum4 a, in HessNum4 b)\n{\n\treturn HessNum4(a.val - b.val, a.g - b.g, a.h - b.h);\n}\n\nHessNum4 sub(in HessNum4 a, in float b)\n{\n\treturn HessNum4(a.val - b, a.g , a.h);\n}\n\nHessNum4 sub(in float a, in HessNum4 b)\n{\n\treturn HessNum4(a - b.val, -b.g , -b.h);\n}\n\nHessNum4 mult(in HessNum4 a, in HessNum4 b)\n{\n\treturn HessNum4(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));\n}\n\nHessNum4 mult(in HessNum4 a, float b)\n{\n\treturn HessNum4(a.val*b, a.g*b, a.h*b);\n}\n\nHessNum4 mult(in float a, in HessNum4 b)\n{\n\treturn HessNum4(b.val*a, b.g*a, b.h*a);\n}\n\nHessNum4 div(in HessNum4 a, in HessNum4 b)\n{\n\tHessNum4 r = HessNum4(a.val / b.val, a.g, a.h );\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g / b.val;\n\n\tr.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);\n\tr.h = r.h / b.val;\n\n\treturn r;\n}\n\nHessNum4 div(in HessNum4 a, float b)\n{\n\treturn HessNum4(a.val/b, a.g/b, a.h/b);\n}\n\nHessNum4 div(float a, in HessNum4 b) {\n\treturn div(a_constH4(a), b);\n}\n\nHessNum4 a_sin(in HessNum4 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum4(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));\n}\n\nHessNum4 a_cos(in HessNum4 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum4(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));\n}\n\nHessNum4 a_exp(in HessNum4 a)\n{\n\tfloat e = exp(a.val);\n\treturn HessNum4(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));\n}\n\nHessNum4 a_log(in HessNum4 a)\n{\n\tfloat ai = 1./a.val;\n\treturn HessNum4(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));\n}\n\nHessNum4 a_pow(in HessNum4 a, float k)\n{\n\tfloat ap = k*consistentPow(a.val,k-1.);\n\treturn HessNum4(consistentPow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*consistentPow(a.val,k-2.) * a_outerProduct(a.g,a.g));\n}\n\nHessNum4 a_pow(in HessNum4 a, in HessNum4 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nHessNum4 a_pow(float a, in HessNum4 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nHessNum4 a_abs(in HessNum4 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\t// Probably better to always make this 0\n\tfloat lpp = a.val == 0. ? AUTO_INFINITY : 0.;\n\treturn HessNum4(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));\n}\n\nHessNum4 a_sqrt(in HessNum4 a)\n{\n\tfloat as = safeSqrt(a.val);\n\tfloat asd = 1. / (2.*as);\n\tfloat asdd = -1./(4.*pow(a.val,3./2.));\n\treturn HessNum4(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g));\n}\n\n//********************************************************************\n//\n// First derivative accumulation is stored in vec2 per parameter\n//\n//********************************************************************\n\nvec2 a_const(in float val)\n{\n    return vec2(val,0.);\n}\n\nvec2 neg(in vec2 u)\n{\n\treturn -u;\n}\n\nvec2 add(in vec2 u, in vec2 v)\n{\n \treturn u + v ;\n}\n\nvec2 add(in vec2 u, in float v)\n{\n \treturn vec2(u.x + v,u.y) ;\n}\n\nvec2 add(in float u, in vec2 v)\n{\n \treturn vec2(u + v.x,v.y) ;\n}\n\nvec2 sub(in vec2 u, in vec2 v)\n{\n \treturn u - v;\n}\n\nvec2 sub(in vec2 u, in float v)\n{\n \treturn vec2(u.x - v,u.y);\n}\n\nvec2 sub(in float u, in vec2 v)\n{\n \treturn vec2(u - v.x,-v.y);\n}\n\nvec2 mult(in vec2 u, in vec2 v)\n{\n \treturn vec2(u.x*v.x, u.y*v.x + v.y*u.x);\n}\n\nvec2 mult(in vec2 u, in float v)\n{\n\treturn v*u;\n}\n\nvec2 mult(in float u, in vec2 v)\n{\n\treturn u*v;\n}\n\nvec2 div(in vec2 u, in vec2 v)\n{\n \treturn vec2(u.x / v.x, (u.y*v.x - v.y*u.x)/(v.x*v.x));\n}\n\nvec2 div(in vec2 u, in float v)\n{\n \treturn u / v;\n}\n\nvec2 div(in float u, in vec2 v) {\n\treturn u / v;\n}\n\nvec2 a_sin(in vec2 u)\n{\n    return vec2(sin(u.x),u.y * cos(u.x));\n}\n\nvec2 a_cos(in vec2 u)\n{\n \treturn vec2(cos(u.x),-u.y*sin(u.x));\n}\n\nvec2 a_exp(in vec2 u)\n{\n \tvec2 r = vec2(exp(u.x));\n    r.y *= u.y;\n    return r;\n}\n\nvec2 a_log(in vec2 u)\n{\n    return vec2(log(u.x),u.y/u.x);\n}\n\nvec2 a_pow(in vec2 u,in float k)\n{\n    return vec2(consistentPow(u.x,k),k*consistentPow(u.x,k-1.)*u.y);\n}\n\nvec2 a_pow(in vec2 a, in vec2 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nvec2 a_pow(float a, in vec2 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nvec2 a_abs(in vec2 u)\n{\n    return vec2(abs(u.x),sign(u.x)*u.y);\n}\n\nvec2 a_sqrt(in vec2 u)\n{\n\tfloat us = safeSqrt(u.x);\n\treturn vec2(us,u.y/(2.*us));\n}\n\n\n//********************************************************************\n//\n// Second derivative accumulation is stored in vec3 per parameter\n//\n//********************************************************************\n\nvec3 a_const2D(in float val)\n{\n\treturn vec3(val,0.,0.);\n}\n\nvec3 add(in vec3 u, in vec3 v)\n{\n\treturn u + v;\n}\n\nvec3 add(in vec3 u, in float v)\n{\n\treturn vec3(u.x + v, u.y, u.z);\n}\n\nvec3 add(in float u, in vec3 v)\n{\n\treturn vec3(u+v.x, v.y,v.z);\n}\n\nvec3 neg(in vec3 u)\n{\n\treturn -u;\n}\n\nvec3 sub(in vec3 u, in vec3 v)\n{\n\treturn u - v;\n}\n\nvec3 sub(in vec3 u, in float v)\n{\n\treturn vec3(u.x - v, u.y, u.z);\n}\n\nvec3 sub(in float u, in vec3 v)\n{\n\treturn vec3(u - v.x, - v.y, -v.z);\n}\n\nvec3 mult(in vec3 u, in vec3 v)\n{\n\treturn vec3(u.x*v.x, u.y*v.x + v.y*u.x, u.z*v.x + 2.*u.y*v.y + u.x * v.z);\n}\n\nvec3 mult(in vec3 u, in float v)\n{\n\treturn u*v;\n}\n\nvec3 mult(in float u, in vec3 v)\n{\n\treturn u*v;\n}\n\nvec3 div(in vec3 u, in vec3 v)\n{\n \treturn vec3(u.x / v.x, (u.y*v.x - v.y*u.x)/(v.x*v.x),(v.x*v.x*u.z - v.x*(2.*u.y*v.y + u.x*v.z) + 2.*u.x*v.y*v.y)/(v.x*v.x*v.x));\n}\n\nvec3 div(in vec3 u, in float v)\n{\n\treturn u / v;\n}\n\nvec3 div(in float u, in vec3 v) {\n\treturn u / v;\n}\n\nvec3 a_sin(in vec3 u)\n{\n    return vec3(sin(u.x),u.y * cos(u.x),u.z*cos(u.x) - u.y*u.y*sin(u.x));\n}\n\nvec3 a_cos(in vec3 u)\n{\n \treturn vec3(cos(u.x),-u.y*sin(u.x),-u.y*u.y*cos(u.x) - u.z*sin(u.x));\n}\n\nvec3 a_exp(in vec3 u)\n{\n \tvec3 r = vec3(exp(u.x));\n    r.y *= u.y;\n\tr.z *= (u.z + u.y*u.y);\n    return r;\n}\nvec3 a_log(in vec3 u)\n{\n    return vec3(log(u.x),u.y/u.x,(u.x*u.z - u.y*u.y)/(u.x*u.x));\n}\n\nvec3 a_pow(in vec3 u,in float k)\n{\n    return vec3(consistentPow(u.x,k),k*consistentPow(u.x,k-1.)*u.y,k*consistentPow(u.x,k-2.)*((k-1.)*u.y*u.y + u.x*u.z));\n}\n\nvec3 a_pow(in vec3 a, in vec3 k)\n{\n\treturn a_exp(mult(k, a_log(a)));\n}\n\nvec3 a_pow(float a, in vec3 k)\n{\n\treturn a_exp(mult(k, log(a)));\n}\n\nvec3 a_abs(in vec3 u)\n{\n\t// Probably best to just ignore special case\n\t// this throws hella warnings\n    // return vec3(abs(u.x),sign(u.x)*u.y,sign(u.x)*u.z + (u.x !=0. ? 0. : 2.*AUTO_INFINITY*u.y*u.y));\n    return vec3(abs(u.x),sign(u.x)*u.y,sign(u.x)*u.z);\n}\n\nvec3 a_sqrt(in vec3 u)\n{\n\tfloat us = safeSqrt(u.x);\n\treturn vec3(us,u.y/(2.*us),(2.*u.x*u.z - u.y*u.y)/(4.*pow(u.x,3./2.)));\n}\n\n\n//********************************************************************\n//\n// Convenience defines for gradients and jacobians\n//\n//********************************************************************\n\n\n//********************************************************************\n//\n// GradNum based gradients\n//\n//********************************************************************\n#define GRAD2(f,u,v,result) {result = f(GradNum2(u,vec2(1.,0.)),GradNum2(v,vec2(0.,1.)));}\n\n\n#define GRAD3(f,u,v,w,result) {result = f(GradNum3(u,vec3(1.,0.,0.)),GradNum3(v,vec3(0.,1.,0.)),GradNum3(w,vec3(0.,0.,1.)));}\n\n\n#define GRAD4(f,u,v,w,x,result) {result = f(GradNum4(u,vec4(1.,0.,0.,0.)),GradNum4(v,vec4(0.,1.,0.,0.)),GradNum4(w,vec4(0.,0.,1.,0.)),GradNum4(x,vec4(0.,0.,0.,1.)));}\n\n\n//********************************************************************\n//\n// vec2 based gradients\n//\n//********************************************************************\n\n#define GRAD2_v(f,u,v,result) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.);result = vec2(f(uGrad,vGrad).y,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  result.y = f(uGrad,vGrad).y;}\n\n#define GRAD3_v(f,u,v,w,result) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.);result = vec3(f(uGrad,vGrad,wGrad).y,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.); result.y = f(uGrad,vGrad,wGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.); result.z = f(uGrad,vGrad,wGrad).y;}\n\n#define GRAD4_v(f,u,v,w,x,result) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.);result = vec4(f(uGrad,vGrad,wGrad,xGrad).y,0.,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.); result.y = f(uGrad,vGrad,wGrad,xGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.);vec2 xGrad = vec2(x,0.); result.z = f(uGrad,vGrad,wGrad,xGrad).y;vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,1.); result.w = f(uGrad,vGrad,wGrad,xGrad).y;}\n\n#define GRAD2_VALUE_v(f,u,v,grad,value) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); grad = f(uGrad,vGrad).yx; value = grad.y; uGrad = vec2(u,0.); vGrad = vec2(v,1.);  grad.y = f(uGrad,vGrad).y;}\n\n#define GRAD3_VALUE_v(f,u,v,w,grad,value) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.); vec2 r_w_value = f(uGrad,vGrad,wGrad);value = r_w_value.x; grad = vec3(r_w_value.y,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.); grad.y = f(uGrad,vGrad,wGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.); grad.z = f(uGrad,vGrad,wGrad).y;}\n\n#define GRAD4_VALUE_v(f,u,v,w,x,grad,value) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.);vec2 r_w_value = f(uGrad,vGrad,wGrad,xGrad);value = r_w_value.x; grad = vec4(r_w_value.y,0.,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.); grad.y = f(uGrad,vGrad,wGrad,xGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.);vec2 xGrad = vec2(x,0.); grad.z = f(uGrad,vGrad,wGrad,xGrad).y;vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,1.); grad.w = f(uGrad,vGrad,wGrad,xGrad).y;}\n\n//********************************************************************\n//\n// Jacobians for vec2 based gradients\n//\n//********************************************************************\n// Without result\n#define JACOBI2_v(f1,f2,u,v,result) { vec2 gradResult = vec2(0.); GRAD2_v(f1,u,v,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; }\n\n#define JACOBI3_v(f1,f2,f3,u,v,w,result) { vec3 gradResult = vec3(0.); GRAD3_v(f1,u,v,w,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z;}\n\n#define JACOBI4_v(f1,f2,f3,f4,u,v,w,x,result) { vec4 gradResult = vec4(0.); GRAD4_v(f1,u,v,w,x,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w; GRAD4_v(f4,u,v,w,x,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z; result[3][3] = gradResult.w;}\n\n#define JACOBI23_v(f1,f2,u,v,w,result) {vec3 gradResult = vec3(0.); GRAD3_v(f1,u,v,w,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; }\n\n#define JACOBI24_v(f1,f2,u,v,w,x,result) { vec4 gradResult = vec4(0.); GRAD4_v(f1,u,v,w,x,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w;}\n\n#define JACOBI32_v(f1,f2,f3,u,v,result) { vec2 gradResult = vec2(0.); GRAD2_v(f1,u,v,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; }\n\n#define JACOBI34_v(f1,f2,f3,u,v,w,x,result) { vec4 gradResult = vec4(0.); GRAD4_v(f1,u,v,w,x,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w;}\n\n#define JACOBI42_v(f1,f2,f3,f4,u,v,result) { vec2 gradResult = vec2(0.); GRAD2_v(f1,u,v,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; vec2 gradResult = vec2(0.); GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; GRAD2_v(f4,u,v,gradResult); result[3][1] = gradResult.x;result[3][1] = gradResult.y;}\n\n#define JACOBI43_v(f1,f2,f3,f4,u,v,w,result) { vec3 gradResult = vec3(0.); GRAD3_v(f1,u,v,w,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; GRAD3_v(f4,u,v,w,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z;}\n\n// With result\n#define JACOBI2_VALUE_v(f1,f2,u,v,result,value) { vec2 gradResult = vec2(0.); GRAD2_VALUE_v(f1,u,v,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; }\n\n#define JACOBI3_VALUE_v(f1,f2,f3,u,v,w,result,value) { vec3 gradResult = vec3(0.); GRAD3_VALUE_v(f1,u,v,w,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z;}\n\n#define JACOBI4_VALUE_v(f1,f2,f3,f4,u,v,w,x,result,value) { vec4 gradResult = vec4(0.); GRAD4_VALUE_v(f1,u,v,w,x,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w; GRAD4_v(f4,u,v,w,x,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z; result[3][3] = gradResult.w;}\n\n#define JACOBI23_VALUE_v(f1,f2,u,v,w,result,value) {vec3 gradResult = vec3(0.); GRAD3_VALUE_v(f1,u,v,w,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; }\n\n#define JACOBI24_VALUE_v(f1,f2,u,v,w,x,result,value) { vec4 gradResult = vec4(0.); GRAD4_VALUE_v(f1,u,v,w,x,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w;}\n\n#define JACOBI32_VALUE_v(f1,f2,f3,u,v,result,value) { vec2 gradResult = vec2(0.); GRAD2_VALUE_v(f1,u,v,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; }\n\n#define JACOBI34_VALUE_v(f1,f2,f3,u,v,w,x,result,value) { vec4 gradResult = vec4(0.); GRAD4_VALUE_v(f1,u,v,w,x,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w;}\n\n#define JACOBI42_VALUE_v(f1,f2,f3,f4,u,v,result,value) { vec2 gradResult = vec2(0.); GRAD2_VALUE_v(f1,u,v,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; vec2 gradResult = vec2(0.); GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; GRAD2_v(f4,u,v,gradResult); result[3][1] = gradResult.x;result[3][1] = gradResult.y;}\n\n#define JACOBI43_VALUE_v(f1,f2,f3,f4,u,v,w,result,value) { vec3 gradResult = vec3(0.); GRAD3_VALUE_v(f1,u,v,w,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; GRAD3_v(f4,u,v,w,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z;}\n\n//********************************************************************\n//\n// Jacobians for GradNum based gradients\n//\n//********************************************************************\n// Without result\n#define JACOBI2(f1,f2,u,v,result) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; }\n\n#define JACOBI3(f1,f2,f3,u,v,w,result) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z;}\n\n#define JACOBI4(f1,f2,f3,f4,u,v,w,x,result) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w; GRAD4(f4,u,v,w,x,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z; result[3][3] = gradResult.g.w;}\n\n#define JACOBI23(f1,f2,u,v,w,result) {GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; }\n\n#define JACOBI24(f1,f2,u,v,w,x,result) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w;}\n\n#define JACOBI32(f1,f2,f3,u,v,result) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; }\n\n#define JACOBI34(f1,f2,f3,u,v,w,x,result) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w;}\n\n#define JACOBI42(f1,f2,f3,f4,u,v,result) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; vec2 gradResult.g = vec2(0.); GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; GRAD2(f4,u,v,gradResult); result[3][1] = gradResult.g.x;result[3][1] = gradResult.g.y;}\n\n#define JACOBI43(f1,f2,f3,f4,u,v,w,result) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; GRAD3(f4,u,v,w,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z;}\n\n// With result\n#define JACOBI2_VALUE(f1,f2,u,v,result,value) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; }\n\n#define JACOBI3_VALUE(f1,f2,f3,u,v,w,result,value) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z;}\n\n#define JACOBI4_VALUE(f1,f2,f3,f4,u,v,w,x,result,value) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult.g,value); value = gradResult.val;  result[0][0] = gradResult.g.x; result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w; GRAD4(f4,u,v,w,x,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z; result[3][3] = gradResult.g.w;}\n\n#define JACOBI23_VALUE(f1,f2,u,v,w,result,value) {GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; }\n\n#define JACOBI24_VALUE(f1,f2,u,v,w,x,result,value) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult);  value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w;}\n\n#define JACOBI32_VALUE(f1,f2,f3,u,v,result,value) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); value.x = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); value.y = gradResult.val; result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; GRAD2(f3,u,v,gradResult); value.z = gradResult.val; result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; }\n\n#define JACOBI34_VALUE(f1,f2,f3,u,v,w,x,result,value) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w;}\n\n#define JACOBI42_VALUE(f1,f2,f3,f4,u,v,result,value) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; vec2 gradResult.g = vec2(0.); GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; GRAD2(f4,u,v,gradResult); result[3][1] = gradResult.g.x;result[3][1] = gradResult.g.y;}\n\n#define JACOBI43_VALUE(f1,f2,f3,f4,u,v,w,result,value) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; GRAD3(f4,u,v,w,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z;}\n\n\n//********************************************************************\n//\n// Hessians\n//\n//********************************************************************\n#define HESSIAN2(f,u,v,result) { vec2 uGrad = vec2(1.,0.); HessNum2 uHessian = HessNum2(u,uGrad,mat2(0.)); vec2 vGrad = vec2(0.,1.); HessNum2 vHessian = HessNum2(v,vGrad,mat2(0.)); result = f(uHessian,vHessian);}\n\n#define HESSIAN3(f,u,v,w,result) { vec3 uGrad = vec3(1.,0.,0.); HessNum3 uHessian = HessNum3(u,uGrad,mat3(0.)); vec3 vGrad = vec3(0.,1.,0.); HessNum3 vHessian = HessNum3(v,vGrad,mat3(0.)); vec3 wGrad = vec3(0.,0.,1.); HessNum3 wHessian = HessNum3(w,wGrad,mat3(0.)); result = f(uHessian,vHessian,wHessian);}\n\n#define HESSIAN4(f,u,v,w,x,result) { vec4 uGrad = vec4(1.,0.,0.,0.); HessNum4 uHessian = HessNum4(u,uGrad,mat4(0.)); vec4 vGrad = vec4(0.,1.,0.,0.); HessNum4 vHessian = HessNum4(v,vGrad,mat4(0.)); vec4 wGrad = vec4(0.,0.,1.,0.); HessNum4 wHessian = HessNum4(w,wGrad,mat4(0.)); vec4 xGrad = vec4(0.,0.,1.,0.); HessNum4 xHessian = HessNum4(x,xGrad,mat4(0.)); result = f(uHessian,vHessian,wHessian,xHessian);}\n\n\n//********************************************************************\n//\n// Custom Escher Code\n//\n//********************************************************************\n\n\nHessNum3 a_constH3(in HessNum3 val)\n{\n\treturn val;\n}\n\nGradNum2 a_constG2(in GradNum2 val)\n{\n\treturn val;\n}\n"},1766:function(e,t){e.exports="{{autoDiffLibrary}}\n\nvarying vec3 vertexPosition;\nvarying vec3 surfaceNormal;\n\nconst float epsilon = .0001;\n\nuniform bool isFrontSide;\nuniform float spaceScale;\n{{sliderUniformDeclarations}}\n\nstruct SurfaceFunctionInfo {\n  vec3 value;\n  vec3 partialU;\n  vec3 partialV;\n  vec3 normal;\n};\n\n\nmat4 transpose(mat4 matrix){\n    vec4 col1 = vec4(matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0]);\n    vec4 col2 = vec4(matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1]);\n    vec4 col3 = vec4(matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2]);\n    vec4 col4 = vec4(matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n\n    mat4 transposed = mat4(col1, col2, col3, col4);\n    return transposed;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nbool isNaN(float value){\n  return !((value > 0.0) || (value <= 0.0));\n}\n\nbool isNaN(vec3 value){\n  return isNaN(value.x) || isNaN(value.y) ||isNaN(value.z);\n}\n\nfloat linearInterpolate(float domainStart, float domainStop, float rangeStart, float rangeStop, float value)\n{\n    float slope = (rangeStart - rangeStop) / (domainStart - domainStop);\n    return (value - domainStart) * slope + rangeStart;\n}\n\nGradNum2 externalFunctionForX(\n  in GradNum2 {{firstParameterName}},\n  in GradNum2 {{secondParameterName}}\n) {\n  return {{externalFunctionX}};\n}\n\nGradNum2 externalFunctionForY(\n  in GradNum2 {{firstParameterName}},\n  in GradNum2 {{secondParameterName}}\n) {\n  return {{externalFunctionY}};\n}\n\nGradNum2 externalFunctionForZ(\n  in GradNum2 {{firstParameterName}},\n  in GradNum2 {{secondParameterName}}\n) {\n  return {{externalFunctionZ}};\n}\n\nvec3 estimateNormal(vec2 p, float delta) {\n  vec3 value;\n  vec3 valueMinusDeltaU;\n  vec3 valueMinusDeltaV;\n\n  mat3 throwawayJacobian;\n\n  JACOBI32_VALUE(\n    externalFunctionForX,\n    externalFunctionForY, \n    externalFunctionForZ, \n    p.x, p.y, throwawayJacobian, value);\n  JACOBI32_VALUE(\n    externalFunctionForX,\n    externalFunctionForY, \n    externalFunctionForZ, \n    p.x-delta, p.y, throwawayJacobian, valueMinusDeltaU);\n  JACOBI32_VALUE(\n    externalFunctionForX,\n    externalFunctionForY, \n    externalFunctionForZ, \n    p.x, p.y-delta, throwawayJacobian, valueMinusDeltaV);\n\n  vec3 partialU = (valueMinusDeltaU-value)/delta;\n  vec3 partialV = (valueMinusDeltaV-value)/delta;\n  return normalize(cross(partialU, partialV));\n}\n\nSurfaceFunctionInfo evaluateFunctionAt(vec2 p) {\n  vec3 value;\n  mat3 jacobian;\n  JACOBI32_VALUE(\n    externalFunctionForX,\n    externalFunctionForY, \n    externalFunctionForZ, \n    p.x, p.y, jacobian, value);\n\n\n  vec3 normal = normalize(cross(jacobian[0], jacobian[1]));\n  \n  if (isNaN(normal)) {\n    normal = estimateNormal(p, epsilon);\n  }\n\n\n  return SurfaceFunctionInfo(\n    value,\n    jacobian[0],\n    jacobian[1],\n    normal\n  );\n}\n\nvoid main() {\n\n    //We assume that if there are any dependencies between parameterVariables, it is that v has a dependency on u.\n    //We make this happen on the typescript side.\n    vec2 uParamBounds = {{firstParameterBounds}};\n    float {{firstParameterName}} = mix(uParamBounds.x, uParamBounds.y, uv.x);\n    vec2 vParamBounds = {{secondParameterBounds}};\n    float {{secondParameterName}} = mix(vParamBounds.x, vParamBounds.y, uv.y);\n\n    //TODO: This could be cleaner\n    vec2 transformedPos = vec2( {{firstParameterName}}, {{secondParameterName}});\n\n    SurfaceFunctionInfo surfaceInfo = evaluateFunctionAt(transformedPos);\n\n    vec3 vertexPositionWorldSpace = surfaceInfo.value/spaceScale; \n    vec4 vertexPositionCameraSpace = modelViewMatrix * vec4(vertexPositionWorldSpace, 1.0); \n    gl_Position = projectionMatrix * vertexPositionCameraSpace;\n    surfaceNormal = mat3(inverse(transpose(viewMatrix))) * surfaceInfo.normal;\n    if (!isFrontSide) {\n      surfaceNormal *= -1.;\n    }\n    vertexPosition = vertexPositionCameraSpace.xyz;\n} \n"},1767:function(e,t){e.exports="#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n\nprecision mediump float;\n\nvarying vec3 vertexPosition;\nvarying vec3 surfaceNormal;\n\nuniform vec3 color;\n\nconst float shininess = 20.0;\nconst vec3 specularColor = vec3(0.1);\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * p: position of point being lit\n * eye: the position of the camera\n * light.position: the position of the light\n * light.color: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 position, vec3 normal, PointLight light) {\n    //TODO: Instead of doing this all in eye space, do it in world space. Pass along an\n    // inverse view matrix to get the lights' positions in world space, since they're in stupid \n    // camera space right now.\n\n\tvec3 worldLightPosition = light.position;\n\n    vec3 N = normal;\n    //The light's position needs to be in world coordinates\n    vec3 L = normalize(worldLightPosition - position);\n    vec3 V = normalize(-1.0 *  position);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return light.color * (color * dotLN);\n    }\n\n    return light.color * \n        (color * dotLN + specularColor * pow(dotRV, shininess));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 p, vec3 normal) {\n    vec3 reflectedColor = vec3(0.0, 0.0, 0.0);\n\treflectedColor += color*ambientLightColor;\n    \n    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n        reflectedColor += phongContribForLight(p, normal, pointLights[i]);\n    }\n    return reflectedColor;\n}\n\nvec4 colorFromUnitVector(vec3 v) {\n    // scale from -1 -> 1 to 0 -> 1\n    vec3 color = v * 0.5 + vec3(0.5);\n    return vec4(color, 1.0);\n}\n\nvoid main() {\n \n  vec4 finalColor = vec4(phongIllumination(vertexPosition, normalize(surfaceNormal)), 1.0);\n\n\tgl_FragColor =  finalColor;\n}\n"},1768:function(e,t){e.exports="varying vec2 vTexcoord;\n\nvoid main() {\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position = vec4(position, 1.0);\n    vTexcoord = uv;\n} "},1769:function(e,t){e.exports="#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <packing>\n\n{{autoDiffLibrary}}\n\nuniform mat4 inverseViewMatrix;\nuniform float verticalFOV;\nuniform mat4 cameraRotation;\n// uniform sampler2D previousSceneTexture;\n// uniform sampler2D depthTexture;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float aspectRatio;\nuniform float spaceScale;\nuniform vec3 surfaceColor;\n// uniform mat4 boundsMatrix;\n// uniform BoundingPlanes boundingPlanes;\n{{sliderUniformDeclarations}}\n\nvarying vec2 vTexcoord;\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 100.0;\nconst float EPS = 0.0001;\n\n//SURFACE PARAMS -- COULD BE PASSED IN\nconst vec3 SPECULAR_COLOR = vec3(0.2, 0.2, 0.2);\nconst float SHININESS = 10.0;\n\nstruct Scalar3DInfo {\n    float value;\n    vec3 gradient;\n    mat3 hessian;\n};\n\nHessNum3 functionDefinition(\n  in HessNum3 external_x,\n  in HessNum3 external_y,\n  in HessNum3 external_z\n) {\n    return {{autoDiffFunctionDefinition}};\n}\n\nScalar3DInfo evaluateFunctionAt(vec3 p) {\n  HessNum3 result;\n  HESSIAN3(functionDefinition, p.x, p.y, p.z, result);\n\n  return Scalar3DInfo(result.val, result.g, result.h);\n}\n\nvec3 getSurfaceNormalAt(vec3 p) {\n    //The normal on the surface is the gradient of the distance function\n    return normalize(evaluateFunctionAt(p).gradient);\n}\n\nfloat implicitDistance(vec3 p) {\n    vec3 scaledLocation = p*spaceScale;\n    Scalar3DInfo evaluatedFunction = evaluateFunctionAt(scaledLocation);\n    float estimatedDistance = evaluatedFunction.value/length(evaluatedFunction.gradient);\n    float rescaledDistance = estimatedDistance / spaceScale;\n    return rescaledDistance;\n}\n\nstruct RaymarchResults {\n    bool surfaceHit;\n    int numSteps;\n    vec3 position;\n    vec3 normal;\n};\n\nRaymarchResults raymarch(vec3 origin, vec3 marchingDirection, float start, float end)\n{\n    float startingSign = sign(implicitDistance(origin + start * marchingDirection ));\n    float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float safeStepDist = implicitDistance(origin + depth * marchingDirection);\n        if (startingSign * safeStepDist < EPS) {\n            vec3 position = origin + depth * marchingDirection;\n            vec3 normal = startingSign * getSurfaceNormalAt(position);\n            return RaymarchResults(true, i, position, normal); \n        }\n\n        depth += abs(safeStepDist);\n\n        if (depth >= end) {\n            vec3 position = origin + depth * marchingDirection;\n            return RaymarchResults(false, i, position, vec3(0));\n        }\n    }\n    vec3 position = origin + depth * marchingDirection;\n    return RaymarchResults(false, MAX_MARCHING_STEPS, position, vec3(0));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * p: position of point being lit\n * eye: the position of the camera\n * light.position: the position of the light\n * light.color: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 worldPos, vec3 normal, vec3 worldEye, PointLight light) {\n    //TODO: Instead of doing this all in eye space, do it in world space. Pass along an\n    // inverse view matrix to get the lights' positions in world space, since they're in stupid \n    // camera space right now.\n\n\tvec3 worldLightPosition = (inverseViewMatrix*vec4(light.position, 1.0)).xyz;\n\n    vec3 N = normal;\n    //The light's position needs to be in world coordinates\n    vec3 L = normalize(worldLightPosition - worldPos);\n    vec3 V = normalize(worldEye - worldPos);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } else {\n        // RaymarchResults lightMarch = raymarch(worldPos, L, MIN_DIST, MAX_DIST);\n        // if (lightMarch.surfaceHit) {\n        //     //self-shadowed!\n        //     return vec3(0.0, 0.0, 0.0);\n        // }\n    }\n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return light.color * (surfaceColor * dotLN);\n    }\n    return light.color * \n        (surfaceColor * dotLN + SPECULAR_COLOR * pow(dotRV, SHININESS));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 p, vec3 normal, vec3 eye) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += ambientLightColor.rgb * surfaceColor;\n    \n    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n        color += phongContribForLight(p, normal, eye, pointLights[i]);\n    }\n    return color;\n}\n\nvec3 calculateRayDirection(){\n    //Shift from 0 -> 1 tex coords to -1 -> 1\n    vec2 xyDirection = (vTexcoord * 2.0) - vec2(1.0);\n    //Based off of the camera's angle, calculate the distance to the \"image plane\",\n    //by default looking down the -z axis\n\tfloat zDirection = -1.0/tan(radians(verticalFOV)/2.0);\n    vec3 cameraSpaceDirection = vec3(xyDirection.x*aspectRatio, xyDirection.y, zDirection);\n    vec3 worldSpaceDirection = (cameraRotation * vec4(cameraSpaceDirection, 0.0)).xyz;\n    return normalize(worldSpaceDirection);\n}\n\nvec4 colorFromUnitVector(vec3 v) {\n    // scale from -1 -> 1 to 0 -> 1\n    vec3 color = v * 0.5 + vec3(0.5);\n    return vec4(color, 1.0);\n}\n\nfloat readDepth( sampler2D depthSampler, vec2 coord ) {\n    float fragCoordZ = texture2D( depthSampler, coord ).x;\n    return perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n}\n\nvoid main() {\n    vec4 finalColor;\n    vec3 rayDirection = calculateRayDirection();\n    RaymarchResults raymarchResults = raymarch(cameraPosition, rayDirection, MIN_DIST, MAX_DIST);\n\n    if (!raymarchResults.surfaceHit) {\n        // finalColor = texture2D( previousSceneTexture, vTexcoord);\n        finalColor = vec4(1, 0, 0, 1);\n    } else {\n        // float depth = readDepth( depthTexture, vTexcoord );\n        // float viewZ = (viewMatrix * vec4(raymarchResults.position, 1.0)).z;\n        // if (viewZ > depth) {\n            finalColor = vec4(phongIllumination(raymarchResults.position, raymarchResults.normal, cameraPosition), 1.0);\n        // finalColor = vec4(0, 1, 0, 1);\n        // } else {\n        //     finalColor = texture2D( previousSceneTexture, vTexcoord);\n        // }\n    }\n\n\tgl_FragColor = finalColor;\n}"},1770:function(e,t){e.exports="precision highp float;\n\nattribute vec3 position;\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\nattribute vec2 uv;\nattribute float counters;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform vec3 color;\nuniform float opacity;\nuniform float near;\nuniform float far;\nuniform float sizeAttenuation;\nuniform float spaceScale;\n{{sliderUniformDeclarations}}\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounters;\n\nvec2 fix( vec4 i, float aspect ) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n\t vCounters = counters;\n    return res;\n}\n\nvec3 externalFunction(float {{parameterName}}) {\n    return vec3({{externalFunctionX}}, {{externalFunctionY}}, {{externalFunctionZ}});\n}\n\nvec3 getPositionOnCurve(vec3 inputPosition) {\n    vec2 paramBounds = {{parameterBounds}};\n    float t = mix(paramBounds.x, paramBounds.y, inputPosition.x);\n    return externalFunction(t)/spaceScale;\n}\n\nvoid main() {\n\n    float aspect = resolution.x / resolution.y;\n\tfloat pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);\n\n    vColor = vec4( color, opacity );\n    vUV = uv;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( getPositionOnCurve(position), 1.0 );\n    vec4 prevPos = m * vec4( getPositionOnCurve(previous), 1.0 );\n    vec4 nextPos = m * vec4( getPositionOnCurve(next), 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n\t float pixelWidth = finalPosition.w * pixelWidthRatio;\n    float w = 1.8 * pixelWidth * lineWidth * width;\n\n    if( sizeAttenuation == 1. ) {\n        w = 1.8 * lineWidth * width;\n    }\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;\n    vec2 normal = vec2( -dir.y, dir.x );\n    normal.x /= aspect;\n    normal *= .5 * w;\n\n    vec4 offset = vec4( normal * side, 0.0, 1.0 );\n    finalPosition.xy += offset.xy;\n\n    gl_Position = finalPosition;\n}"},307:function(e,t,n){"use strict";n.r(t);var a=n(1);class r extends Error{constructor(){super(...arguments);this.kind="ConfigurationError"}}var s=n(773);var i=n(402);const o={blue:new s["Color"]("#0C6AC7"),red:new s["Color"]("#D61F06"),green:new s["Color"]("#20A900"),orange:new s["Color"]("#EC7300"),magenta:new s["Color"]("#E81990"),yellow:new s["Color"]("#FEDF53"),purple:new s["Color"]("#302B94"),black:new s["Color"]("#000000")};function u(e){return o[e]}const l=Object(i["OrderedSet"])(["blue","red","green","orange","magenta","yellow","purple","black"]);const c="black";let d=Object(i["Set"])();function v(){const e=l.subtract(d).first(null);if(e){d=d.add(e);return e}else{return c}}function m(){d=Object(i["Set"])()}function f(e){const t=e.sliderVariables?Object(i["List"])(e.sliderVariables).map(e=>e.color).toSet():Object(i["Set"])();const n=Object(i["Set"])(e.components.map(e=>e.color));d=d.union(t,n)}function g(e){return Object.assign(Object.assign({},e),{color:e.color=="automatic"?v():e.color})}var h=n(282);var p=n.n(h);function b(){function e(){return Math.floor((1+Math.random())*65536).toString(16).substring(1)}return e()+e()+e()+e()}function w(e,t,n,a,r,s,i,o){const u=b();const l=document.createElement("div");l.id=`${u}`;i.appendChild(l);const c=n.map(e=>R(e)).toArray();p.a.createInteractive({visualizationKey:u,authoredData:{visualization:u,type:"3d",width:e,height:t,sliders:c,onSliderChanged:r,latexExpressions:a.toArray(),interactiveSlug:s}});const d=document.querySelector(`#graph-3d-${u}`);if(d){d.appendChild(o)}else{throw new Error("Couldn't find any dom elements to render to! Did the 2D grapher initialize correctly?")}}function R(e){const t=Object.assign({precision:2,step:0,hasPlayButton:false,startingValue:(e.max+e.min)/2,showTicks:true,showLabel:true},e);const n={latex:t.name,value:t.startingValue,min:t.min,max:t.max,step:t.step,precision:t.precision,color:"#"+u(t.color).getHexString(),hideScale:!t.showTicks,hideSteps:!t.showTicks,hideLabel:!t.showLabel,animated:t.hasPlayButton};if(t.step>0){n.scaleStep=t.step}return n}var y=n(799);var x;(function(e){function t(e){let t=Object(i["Set"])();if(typeof e==="string"){const n=y["parse"](e);n.traverse(e=>{if(e.isSymbolNode&&e.name!==undefined&&e.name!=="pi"){t=t.add(e.name)}});return t}else{return Object(i["Set"])()}}e.getVariables=t;function n(e){if(typeof e==="string"){const t=y["compile"](e);return e=>t.eval(e.toObject())}else{return t=>e}}e.compile=n;function a(e){if(typeof e=="string"){return y["simplify"](e).toString()}else{return e}}e.simplify=a})(x||(x={}));var N;(function(e){function t(e){return i["Set"].union([x.getVariables(e.x),x.getVariables(e.y),x.getVariables(e.z)])}e.getVariables=t;function n(e){const t=x.compile(e.x);const n=x.compile(e.y);const a=x.compile(e.z);return e=>new s["Vector3"](t(e),n(e),a(e))}e.compile=n})(N||(N={}));var G=n(807);const A=Math.PI/16;const _=15*Math.PI/16;const D=-Infinity;const S=Infinity;const H=1;const P=7;class z{constructor(e){this.config=e;const t=new s["PerspectiveCamera"](z.verticalFOV,e.aspectRatio,z.nearPlane,z.farPlane);this.threeJSCamera=t;this.threeJSCamera.up=new s["Vector3"](0,0,1);this.calcFocusPoint=N.compile(e.focusPoint);this.position=e.position}rotateFromMouseOrTouch(e,t){const n=C(this.position.phi+t/-100,A,_);const a=C(this.position.theta+e/-180,D,S);this.position=new s["Spherical"](this.position.radius,n,a)}zoomFromScroll(e){const t=this.position.radius;const n=.001538462;const a=Math.pow(1-n,-e);const r=t*a;const i=C(r,H,P);this.position=new s["Spherical"](i,this.position.phi,this.position.theta)}zoomFromPinch(e){const t=this.position.radius/e;const n=C(t,H,P);this.position.radius=n}positionCamera(e){let t=(new s["Vector3"]).setFromSpherical(this.position);t.applyQuaternion(V);const n=this.calcFocusPoint(e);const a=(new s["Vector3"]).addVectors(t,n);this.threeJSCamera.position.copy(a);this.threeJSCamera.lookAt(n);this.threeJSCamera.updateMatrixWorld(true)}getRenderInfo(){return{worldToCamera:this.threeJSCamera.matrixWorldInverse,cameraToClip:this.threeJSCamera.projectionMatrix,rotation:this.threeJSCamera.quaternion,position:this.threeJSCamera.position,aspectRatio:this.config.aspectRatio}}getPosition(){return this.position}getThreeCamera(){return this.threeJSCamera}setUpOrbitControls(e,t){e.setAttribute("touch-action","none");e.style.cursor="grab";const n=new Map;let a=null;let r=null;e.addEventListener("pointerdown",t=>{t.preventDefault();e.setPointerCapture(t.pointerId);e.style.cursor="grabbing";i(t);if(n.size==1){document.addEventListener("pointermove",o)}});const i=e=>{const t=new s["Vector2"](e.clientX,e.clientY);if(!n.has(e.pointerId)){if(n.size==0){r=t}else if(n.size==1){const e=n.values().next().value;r=t.clone().add(e).divideScalar(2);a=t.distanceTo(e)}}n.set(e.pointerId,t)};const o=e=>{i(e);const t=n.values();const a=t.next().value;const r=t.next().value;if(a&&r&&t.next().done){const e=a.distanceTo(r);l(e);const t=(new s["Vector2"]).add(a).add(r).divideScalar(2);u(t)}else if(a&&!r){u(a)}};const u=e=>{if(r!==null){const n=e.clone().sub(r);this.rotateFromMouseOrTouch(n.x,n.y);t()}r=e};const l=e=>{if(a!==null){this.zoomFromPinch(e/a);t()}a=e};const c=t=>{n.delete(t.pointerId);e.releasePointerCapture(t.pointerId);if(n.size==1){r=n.values().next().value;a=null}if(n.size==0){document.removeEventListener("pointermove",o);r=null;a=null;e.style.cursor="grab"}};document.addEventListener("pointerup",c);document.addEventListener("pointercancel",c);e.addEventListener("wheel",e=>{if(e.deltaY!=0){e.preventDefault();this.zoomFromScroll(e.deltaY);t()}});e.addEventListener("touchstart",e=>{e.preventDefault()})}setUpScrolling(e,t){e.addEventListener("wheel",e=>{if(e.deltaY!=0){this.zoomFromScroll(e.deltaY);e.preventDefault();e.stopPropagation();t()}})}setAspectRatio(e){this.threeJSCamera.aspect=e;this.threeJSCamera.updateProjectionMatrix()}}const V=(new s["Quaternion"]).setFromAxisAngle(new s["Vector3"](1,0,0),Math.PI/2);function C(e,t,n){return Math.min(Math.max(e,t),n)}function M(e){let t=new s["Vector2"];e.forEach(e=>t.add(e));t.divideScalar(e.size);return t}(function(e){e.nearPlane=.1;e.farPlane=100;e.verticalFOV=50})(z||(z={}));class k{constructor(e={}){let t=Object.assign(Object.assign({},I),e);const n=new s["PointLight"](t.color,t.intensity);n.position.copy(t.position);this.object3D=n}}const I={position:new s["Vector3"],color:new s["Color"]("white"),intensity:1};class E{constructor(e={}){let t=Object.assign(Object.assign({},O),e);const n=new s["AmbientLight"](t.color,t.intensity);this.object3D=n}}const O={color:new s["Color"]("white"),intensity:1};function L(){let e=new s["Group"];e.add(new k({position:new s["Vector3"](1,.1,2),intensity:.8}).object3D,new k({position:new s["Vector3"](-1,-.1,-2),intensity:.8}).object3D,new E({intensity:.5}).object3D);return e}function T(e){return{value:e}}var F;(function(e){function t(e){return s["UniformsUtils"].merge([s["UniformsLib"]["lights"],e])}e.addLightUniforms=t})(F||(F={}));const $=y["pi"];const U=y["tau"];const j=y["e"];const B={"":$,"":U,e:j};const J=Object(i["Map"])({"":"alpha","":"beta","":"gamma","":"delta","":"epsilon","":"zeta","":"eta","":"theta","":"iota","":"kappa","":"lambda","":"mu","":"nu","":"xi","":"omicron","":"pi","":"rho","":"sigma","":"tau","":"upsilon","":"phi","":"chi","":"psi","":"omega","":"Alpha","":"Beta","":"Gamma","":"Delta","":"Epsilon","":"Zeta","":"Eta","":"Theta","":"Iota","":"Kappa","":"Lambda","":"Mu","":"Nu","":"Xi","":"Omicron","":"Pi","":"Rho","":"Sigma","":"Tau","":"Upsilon","":"Phi","":"Chi","":"Psi","":"Omega"});const W=J.mapEntries(([e,t])=>[t,e]);function q(e){return J.has(e)}function Y(e){return W.has(e)}function X(e){return J.get(e)}function Z(e){return W.get(e)}function Q(e){return X(e)||e}var K=n(1765);var ee=n.n(K);function te(e,t,n){const a=Object(i["Map"])({sliderUniformDeclarations:ae(t),autoDiffLibrary:ee.a});const r=a.merge(n);let s=e;r.forEach((e,t)=>{s=s.replace(new RegExp(`{{${t}}}`,"g"),e)});s=ne(s);return s}function ne(e){return`\n  const float SAFE_SQRT_THRESHOLD = -0.01;\n  float safeSqrt(float x) {\n    return x> SAFE_SQRT_THRESHOLD ? sign(x)*sqrt(abs(x)) : sqrt(x);\n  }\n  float consistentPow(float x, float y) {\n    // This seems to be an okay way to generate a NaN without warnings\n    return x < 0.0 ? x/0.0 : pow(x, y);\n  }\n  ${e}\n  `}function ae(e){return e.keySeq().map(e=>{return`uniform float ${ie(e)};`}).join("\n")}const re=/[-]/g;function se(e){return e.replace(re,e=>`_${e.charCodeAt(0)-"".charCodeAt(0)}`)}function ie(e){const t=Q(e);const n=se(t);return`external_${n}`}function oe(e){const t=e.toString();const n=y["parse"](t);return le(n)}function ue(e){return`vec2(${oe(e.start)}, ${oe(e.stop)})`}function le(e){return e.toString({parenthesis:"all",handler:ce})}function ce(e){if(!e){return}if(e.isOperatorNode){if(!e.args){throw new Error("Check your function")}switch(e.fn){case"pow":const t=le(e.args[0]);const n=le(e.args[1]);return de(t,n);case"mod":return"mod("+le(e.args[0])+","+le(e.args[1])+")"}}else if(e.isFunctionNode){if(!e.args){return}switch(e.name){case"log10":return"(log("+le(e.args[0])+")/log(10.0))";case"log":if(e.args[1]){return"(log("+le(e.args[0])+")/log("+le(e.args[1])+"))"}else{return}case"atan2":return"atan("+le(e.args[0])+","+le(e.args[1])+")";case"cube":const t=le(e.args[0]);return ve(t,3);case"sqrt":return"safeSqrt("+le(e.args[0])+")";default:return`${e.name}(${le(e.args[0])})`}}else if(e.isConstantNode){return Number(e.value).toFixed(2)}else if(e.isSymbolNode){return ie(e.name||"")}return}function de(e,t){const n=Number.parseFloat(t);if(Number.isInteger(n)){return ve(e,n)}else{return`consistentPow(${e}, ${t})`}}function ve(e,t){if(t<=1){return e}else{return`((${e})*(${ve(e,t-1)}))`}}function me(e,t){const n=t.toString();const a=y["parse"](n);return fe(e,a)}function fe(e,t){return t.toString({parenthesis:"all",handler:t=>ge(e,t)})}function ge(e,t){function n(t,n){const a=fe(e,n[0]);return`${t}(${a})`}function a(t,n){const a=fe(e,n[0]);const r=fe(e,n[1]);return`${t}(${a}, ${r})`}if(!t){return}const r=he(e);if(t.isOperatorNode){if(!t.args){throw new Error("Check your function")}switch(t.fn){case"pow":const r=fe(e,t.args[0]);return pe(e,r,t.args[1]);case"add":return a("add",t.args);case"subtract":return a("sub",t.args);case"multiply":return a("mult",t.args);case"divide":return a("div",t.args);case"unaryMinus":return n("neg",t.args)}}else if(t.isFunctionNode){if(!t.args){return}switch(t.name){case"log":return n("a_log",t.args);case"sin":return n("a_sin",t.args);case"cos":return n("a_cos",t.args);case"exp":return n("a_exp",t.args);case"sqrt":return n("a_sqrt",t.args);default:return`${t.name}(${le(t.args[0])})`}}else if(t.isConstantNode){const e=parseFloat(t.value).toFixed(3);return`${r}(${e})`}else if(t.isSymbolNode){const e=t.name||"";return`${r}(${ie(e||"")})`}return}function he(e){switch(e){case"GradNum2":return"a_constG2";case"HessNum3":return"a_constH3"}}function pe(e,t,n){if(n.isConstantNode){const e=Number.parseFloat(n.value);if(Number.isInteger(e)){return be(t,e)}}const a=fe(e,n);return`a_pow(${t}, ${a})`}function be(e,t){if(t<=1){return e}else{return`mult(${e}, ${be(e,t-1)})`}}var we;(function(e){e.defaultScope=Object(i["Map"])(B);function t(e,t){e.forEach((e,n)=>{const a=ie(n);t.uniforms[a]=T(e)})}e.setUniforms=t;function n(t){let n=e.defaultScope;t.forEach(e=>{n=n.set(e.name,e.startingValue||(e.min+e.max)/2)});return n}e.initializeFromSliderVariables=n;function a(e){return Object(i["Set"])(e.keys())}e.getVariableNames=a})(we||(we={}));const Re=.05;class ye{constructor(e,t){Ne(e.position,t);const n=xe(u(e.color));this.object3D=n;this.calculatePosition=N.compile(e.position)}willRender({spaceConfig:e,scope:t}){const n=this.calculatePosition(t);const a=(new s["Vector3"]).copy(n).multiplyScalar(1/e.scale);this.object3D.position.copy(a)}}function xe(e){const t=new s["SphereGeometry"](Re,16,16);const n=new s["MeshPhongMaterial"]({color:e});return new s["Mesh"](t,n)}function Ne(e,t){const n=N.getVariables(e);const a=we.getVariableNames(t);const s=n.subtract(a);if(!s.isEmpty()){const e=s.count()>1;throw new r(`The variable${e?"s":""} ${s.toArray()} in your Point definition ${e?"don't":"doesn't"} appear in either sliderVariables. That means we have no idea where its value comes from.`)}}function Ge(e){throw new Error("Unexpected object: "+e)}var Ae;(function(e){function t(e){let t=new Array;for(const n of e){switch(n.kind){case"Translate":t.push(N.getVariables(n.translate));break;case"ScaleUniform":t.push(x.getVariables(n.scale));break;case"ScalePerAxis":t.push(N.getVariables(n.scale));break;case"RotateAxisAngle":t.push(N.getVariables(n.axis));t.push(x.getVariables(n.angle));break;case"RotateVectorIntoVector":t.push(N.getVariables(n.fromVector));t.push(N.getVariables(n.toVector));break;case"Mirror":t.push(N.getVariables(n.along));break;case"SkewWithNewAxes":t.push(N.getVariables(n.newX));t.push(N.getVariables(n.newY));t.push(N.getVariables(n.newZ));break;default:Ge(n)}}return i["Set"].union(t)}e.getVariables=t;function n(e){let t=new Array;for(const n of e){switch(n.kind){case"Translate":const e=N.compile(n.translate);t.push(t=>{let n=new s["Matrix4"];let a=e(t);n.makeTranslation(a.x,a.y,a.z);return n});break;case"ScaleUniform":const a=x.compile(n.scale);t.push(e=>{let t=new s["Matrix4"];let n=a(e);t.makeScale(n,n,n);return t});break;case"ScalePerAxis":const r=N.compile(n.scale);t.push(e=>{let t=new s["Matrix4"];let n=r(e);t.makeScale(n.x,n.y,n.z);return t});break;case"RotateAxisAngle":const i=N.compile(n.axis);const o=x.compile(n.angle);t.push(e=>{let t=new s["Matrix4"];t.makeRotationAxis(i(e).normalize(),o(e));return t});break;case"RotateVectorIntoVector":const u=N.compile(n.fromVector);const l=N.compile(n.toVector);t.push(e=>{let t=new s["Matrix4"];let n=new s["Quaternion"];n.setFromUnitVectors(u(e).normalize(),l(e).normalize());t.makeRotationFromQuaternion(n);return t});break;case"Mirror":const c=N.compile(n.along);t.push(e=>{let t=c(e).normalize();let n=new s["Matrix4"];n.set(1-2*t.x*t.x,-2*t.x*t.y,-2*t.x*t.z,0,-2*t.y*t.x,1-2*t.y*t.y,-2*t.y*t.z,0,-2*t.z*t.x,-2*t.z*t.y,1-2*t.z*t.z,0,0,0,0,1);return n});break;case"SkewWithNewAxes":const d=N.compile(n.newX);const v=N.compile(n.newY);const m=N.compile(n.newZ);t.push(e=>{let t=new s["Matrix4"];let n=d(e);let a=v(e);let r=m(e);t.set(n.x,a.x,r.x,0,n.y,a.y,r.y,0,n.z,a.z,r.z,0,0,0,0,1);return t});break;default:Ge(n)}}let n=e=>{let n=new s["Matrix4"];for(const a of t){n.premultiply(a(e))}return n};return n}e.compile=n})(Ae||(Ae={}));class _e{constructor(e,t){De(e.name,e.primitive,e.transformChain,t);const n=1;const a=n/2;let r;let i={color:u(e.color),side:s["FrontSide"]};this.baseTransform=new s["Matrix4"];switch(e.primitive.kind){case"Sphere":r=new s["SphereBufferGeometry"](a,64,32);break;case"Cube":r=new s["BoxBufferGeometry"](n,n,n);break;case"Cone":r=new s["ConeBufferGeometry"](a,1,128,1,e.primitive.openEnded);if(e.primitive.openEnded){i.side=s["DoubleSide"]}this.baseTransform.makeRotationX(2*Math.PI/4);break;case"Cylinder":r=new s["CylinderBufferGeometry"](a,a,1,64,1,e.primitive.openEnded);if(e.primitive.openEnded){i.side=s["DoubleSide"]}this.baseTransform.makeRotationX(2*Math.PI/4);break;case"Disc":r=new s["CircleBufferGeometry"](a,32);i.side=s["DoubleSide"];break;case"Plane":r=new s["PlaneBufferGeometry"](n,n);i.side=s["DoubleSide"];break;case"Tetrahedron":r=new s["TetrahedronBufferGeometry"](a);break;case"Octahedron":r=new s["OctahedronBufferGeometry"](a);break;case"Dodecahedron":r=new s["DodecahedronBufferGeometry"](a);break;case"Icosahedron":r=new s["IcosahedronBufferGeometry"](a);break;default:Ge(e.primitive)}const o=new s["MeshPhongMaterial"](i);this.object3D=new s["Mesh"](r,o);this.object3D.matrixAutoUpdate=false;this.calculateTransform=Ae.compile(e.transformChain)}willRender({spaceConfig:e,scope:t}){let n=1/e.scale;let a=(new s["Matrix4"]).makeScale(n,n,n);this.object3D.matrix.copy(this.baseTransform);this.object3D.matrix.premultiply(this.calculateTransform(t));this.object3D.matrix.premultiply(a);this.object3D.matrixWorldNeedsUpdate=true}}function De(e,t,n,a){const s=Ae.getVariables(n);const i=we.getVariableNames(a);const o=s.subtract(i);if(!o.isEmpty()){const n=o.count()>1;throw new r(`The variable${n?"s":""} "${o.toArray()}" in the definition of the ${t.kind} named "${e}" ${n?"don't":"doesn't"} appear in either sliderVariables. That means we have no idea where its value comes from.`)}}var Se=n(1766);var He=n.n(Se);var Pe=n(1767);var ze=n.n(Pe);const Ve=50*50;const Ce=new s["PlaneGeometry"](2,2,Math.sqrt(Ve),Math.sqrt(Ve));class Me{constructor(e,t){Ee(e.parameterVariables,e.functionDefinition,t);const n=Oe(e.parameterVariables);const a=new s["Group"];this.color=u(e.color);const r=ke(n,e.functionDefinition,t);const i=Ie();this.shaderFrontSide=new s["ShaderMaterial"]({uniforms:F.addLightUniforms({isFrontSide:T(true),color:T(this.color),spaceScale:T(1)}),vertexShader:r,fragmentShader:i,side:s["FrontSide"],lights:true});this.shaderBackSide=new s["ShaderMaterial"]({uniforms:F.addLightUniforms({isFrontSide:T(false),color:T(this.color),spaceScale:T(1)}),vertexShader:r,fragmentShader:i,side:s["BackSide"],lights:true});const o=new s["Mesh"](Ce,this.shaderFrontSide);const l=new s["Mesh"](Ce,this.shaderBackSide);a.add(o,l);this.object3D=a}willRender({scope:e,spaceConfig:t}){we.setUniforms(e,this.shaderFrontSide);we.setUniforms(e,this.shaderBackSide);this.shaderFrontSide.uniforms.spaceScale.value=t.scale||1;this.shaderBackSide.uniforms.spaceScale.value=t.scale||1}}function ke(e,t,n){return te(He.a,n,Object(i["Map"])({firstParameterBounds:ue(e[0]),secondParameterBounds:ue(e[1]),firstParameterName:ie(e[0].name),secondParameterName:ie(e[1].name),externalFunctionX:me("GradNum2",t.x),externalFunctionY:me("GradNum2",t.y),externalFunctionZ:me("GradNum2",t.z)}))}function Ie(){return ze.a}function Ee(e,t,n){const a=i["Set"].union([x.getVariables(t.x),x.getVariables(t.y),x.getVariables(t.z)]);const s=we.getVariableNames(n);const o=Object(i["Set"])(Object(i["Map"])(B).keys());const u=s.subtract(o);const l=Object(i["Set"])([e[0].name,e[1].name]);const c=i["Set"].intersect([u,l]);if(!c.isEmpty()){throw new r(`You can't have slider variables as your independent parameter variables.\n     Specifically, ${c.toArray()} appears as a slider and as a parameter. `)}const d=i["Set"].intersect([o,l]);if(!d.isEmpty()){throw new r(`You can't use reserved constants as your independent parameter.\n    Specifically, you used ${d.toArray()}.\n    The full list of reserved constants is ${o.toArray()}`)}const v=a.subtract(l).subtract(s);if(!v.isEmpty()){const e=v.count()>1;throw new r(`The variable${e?"s":""} `+`${v.toArray()}`+` ${e?"don't":"doesn't"} appear `+`in either parameterVariables or sliderVariables.\n        That means we have no idea where its value comes from.`)}const m=i["Set"].union([x.getVariables(e[0].start),x.getVariables(e[0].stop)]);const f=i["Set"].union([x.getVariables(e[1].start),x.getVariables(e[1].stop)]);if(m.contains(e[1].name)&&f.contains(e[0].name)){throw new r(`\n      Both of your parameter ranges for your parametric surface depend on each other, causing a circular dependency. \n      Only one parameter can refer to the other parameter in a parametric surface!\n    `)}if(m.contains(e[0].name)){throw new r(`\n      Your parameter named ${e[0].name} refers to itself in its range. That's no good!\n    `)}if(f.contains(e[1].name)){throw new r(`\n      Your parameter named ${e[1].name} refers to itself in its range. That's no good!\n    `)}const g=m.union(f).subtract(l).subtract(u).subtract(o);if(!g.isEmpty()){throw new r(`These variables in your parameter variables' ranges: ${g.toArray()} are neither slider variables nor constants.`)}}function Oe(e){const t=x.getVariables(e[0].start).union(x.getVariables(e[0].stop));if(t.contains(e[1].name)){return[e[1],e[0]]}else{return[e[0],e[1]]}}var Le=n(1768);var Te=n.n(Le);var Fe=n(1769);var $e=n.n(Fe);class Ue{constructor(e,t){Ye(e.equationDefinition,t);const n=new s["PlaneGeometry"](2,2);this.material=Be(e.equationDefinition,t,u(e.color));this.object3D=new s["Mesh"](n,this.material)}willRender({scope:e,cameraSettings:t,spaceConfig:n}){we.setUniforms(e,this.material);const a=(new s["Matrix4"]).getInverse(t.worldToCamera);const r=(new s["Matrix4"]).makeRotationFromQuaternion(t.rotation);this.material.uniforms.cameraToWorld=T(a);this.material.uniforms.cameraRotation=T(r);this.material.uniforms.aspectRatio=T(t.aspectRatio);this.material.uniforms.spaceScale=T(n.scale)}}function je(e){return s["UniformsUtils"].merge([s["UniformsLib"]["lights"],e])}function Be(e,t,n){const a={verticalFOV:T(z.verticalFOV),cameraToWorld:T(new s["Matrix4"]),cameraRotation:T(new s["Matrix4"]),cameraNear:T(z.nearPlane),cameraFar:T(z.farPlane),aspectRatio:T(1),spaceScale:T(1),surfaceColor:T(n)};const r=new s["ShaderMaterial"]({uniforms:je(a),vertexShader:Je(),fragmentShader:We(e,t),lights:true,transparent:true});return r}function Je(){return Te.a}function We(e,t){const{lhs:n,rhs:a}=qe(e);const r=`(${n}) - (${a})`;return te($e.a,t,Object(i["Map"])({autoDiffFunctionDefinition:me("HessNum3",r)}))}function qe(e){const[t,n]=e.split("=");return{lhs:t,rhs:n}}function Ye(e,t){const n=we.getVariableNames(t);const a=Object(i["Set"])(["x","y","z"]);if(typeof e=="string"){const{lhs:t,rhs:s}=qe(e);const o=i["Set"].union([x.getVariables(t),x.getVariables(s)]);const u=o.subtract(n).subtract(a);if(!u.isEmpty()){const e=u.count()>1;throw new r(`The variable${e?"s":""} `+`${u.toArray()}`+` ${e?"don't":"doesn't"} appear `+`in your list of sliderVariables.\n        That means we have no idea where its value comes from.`)}}const s=n.intersect(a);if(!s.isEmpty()){throw new r(`If you're using a Implicit Surface Graph, then x, y, and z cannot be used as slider variables.\n      They'd conflict with the x, y, and z that Implicit Surface Graphs use! I detected that you have at least one slider named:\n      ${s.toArray()}`)}}var Xe=n(1e3);var Ze=n(1770);var Qe=n.n(Ze);const Ke=1e3;const et=new s["Geometry"];const tt=1/(Ke-1);for(var nt=0;nt<Ke;nt++){const e=nt*tt;et.vertices.push(new s["Vector3"](e,0,0))}const at=8;class rt{constructor(e,t,n,a){it(e.parameterVariable,e.functionDefinition,t);const r=new Xe["MeshLine"];r.setGeometry(et);this.material=new Xe["MeshLineMaterial"]({sizeAttenuation:0,color:u(e.color),lineWidth:at,near:n.near,far:n.far,resolution:new s["Vector2"](n.width,n.height),side:s["DoubleSide"]});this.material.vertexShader=st(e.functionDefinition,e.parameterVariable,t);this.material.uniforms.spaceScale=T(a);const i=new s["Mesh"](r.geometry,this.material);this.object3D=i}willRender({scope:e}){we.setUniforms(e,this.material)}}function st(e,t,n){return te(Qe.a,n,Object(i["Map"])({parameterBounds:ue(t),parameterName:ie(t.name),externalFunctionX:oe(e.x),externalFunctionY:oe(e.y),externalFunctionZ:oe(e.z)}))}function it(e,t,n){const a=i["Set"].union([x.getVariables(t.x),x.getVariables(t.y),x.getVariables(t.z)]);const s=we.getVariableNames(n);const o=e.name;const u=Object(i["Set"])(Object(i["Map"])(B).keys());const l=s.subtract(u);if(l.contains(o)){throw new r(`You can't have slider variables as your independent parameter variable.\n     Specifically, ${o} appears as a slider and as a parameter. `)}if(u.contains(o)){throw new r(`You can't use reserved constants as your independent parameter.\n    Specifically, ${o} is a reserved constant.\n    The full list of reserved constants is ${u.toArray()}`)}const c=a.subtract(o).subtract(s);if(!c.isEmpty()){const e=c.count()>1;throw new r(`The variable${e?"s":""} `+`${c.toArray()}`+` ${e?"don't":"doesn't"} appear `+`in either parameterVariables or sliderVariables.\n        That means we have no idea where its value comes from.`)}const d=i["Set"].union([x.getVariables(e.start),x.getVariables(e.stop)]);const v=d.subtract(l).subtract(u);if(!v.isEmpty()){throw new r(`These variables in your parameter variable's range: ${v.toArray()} are neither slider variables nor constants.`)}}const ot=new s["TextureLoader"];function ut(e,t){return ot.load(e,t)}var lt=n(789);const ct=Object(lt["getImageUrl"])("Graph3D/pointing-away.png");const dt=Object(lt["getImageUrl"])("Graph3D/pointing-towards.png");const vt=Object(lt["getImageUrl"])("Graph3D/zero-vector.png");const mt=.05;const ft=8;const gt=30;class ht{constructor(e,t,n,a){Rt(e.tip,e.tail,t);const r=new s["Group"];this.color=u(e.color);this.body=Nt(this.color,n);this.head=Gt(this.color,n);this.pointingAway=this.createSprite(ct,a);this.pointingTowards=this.createSprite(dt,a);this.zeroVector=this.createSprite(vt,a);r.add(this.body,this.head,this.pointingAway,this.pointingTowards,this.zeroVector);this.calculateTipPosition=N.compile(e.tip);this.calculateTailPosition=N.compile(e.tail);this.object3D=r}willRender({spaceConfig:e,scope:t,cameraSettings:n}){const a=this.calculateTipPosition(t);const r=(new s["Vector3"]).copy(a).multiplyScalar(1/e.scale);const i=this.calculateTailPosition(t);const o=(new s["Vector3"]).copy(i).multiplyScalar(1/e.scale);const u=(new s["Matrix4"]).premultiply(n.worldToCamera).premultiply(n.cameraToClip);const l=pt(r,o,n.position,u,e.scale);this.prepareForRender(l)}prepareForRender(e){this.body.matrix.copy(At(e.tail,e.arrowStart));this.head.matrix.copy(At(e.arrowStart,e.tip));const t=gt*e.arrowScale;const n=ft*e.arrowScale;this.head.material.uniforms.lineWidth=T(t);this.body.material.uniforms.lineWidth=T(n);this.hideAllSprites();switch(e.vectorSprite){case"away":wt(this.pointingAway,e.tip,e.spriteOpacity);break;case"towards":wt(this.pointingTowards,e.tip,e.spriteOpacity);break;case"zero":wt(this.zeroVector,e.tail,e.spriteOpacity);break}}hideAllSprites(){this.pointingAway.visible=false;this.pointingTowards.visible=false;this.zeroVector.visible=false}createSprite(e,t){const n=new s["Geometry"];n.vertices.push(new s["Vector3"](1,1,1));const a=ut(e,t);const r=new s["SpriteMaterial"]({color:this.color,map:a,transparent:true,sizeAttenuation:false,depthWrite:false});const i=new s["Sprite"](r);i.scale.set(.05,.05,1);return i}}function pt(e,t,n,a,r){const i=e.clone().applyMatrix4(a);const o=t.clone().applyMatrix4(a);const u=(new s["Vector3"]).subVectors(i,o).normalize();const l=new s["Vector2"](u.x,u.y).length();const c=new s["Vector2"](i.x-o.x,i.y-o.y).length();const d=Math.min(c/2,mt);const v=d/mt;const m=d/l;const f=(new s["Vector3"]).subVectors(i,u.multiplyScalar(m));let g=new s["Matrix4"];g.getInverse(a);let h=f.clone().applyMatrix4(g);const[p,b]=bt(e,t,n,r);if(e.distanceTo(h)>e.distanceTo(t)){h=e}return{tip:e,tail:t,arrowScale:v,arrowStart:h,vectorSprite:p,spriteOpacity:b}}function bt(e,t,n,a){const r=.99;const i=.01;const o=(new s["Vector3"]).subVectors(t,n).normalize();const u=(new s["Vector3"]).subVectors(e,t).length()/a;const l=(new s["Vector3"]).subVectors(e,t).normalize();const c=l.dot(o);if(u<i){const e=(i-u)/i;return["zero",e]}else if(c>r){const e=(c-r)/(1-r);return["away",e]}else if(c<-r){const e=(-r-c)/(1-r);return["towards",e]}else{return["none",0]}}function wt(e,t,n){e.visible=true;e.position.copy(t);e.material.opacity=n}function Rt(e,t,n){const a=i["Set"].union([N.getVariables(e),N.getVariables(t)]);const s=we.getVariableNames(n);const o=a.subtract(s);if(!o.isEmpty()){const e=o.count()>1;throw new r(`The variable${e?"s":""} ${o.toArray()} in your Vector definition ${e?"don't":"doesn't"} appear in either sliderVariables. That means we have no idea where its value comes from.`)}}const yt=new s["Geometry"];yt.vertices.push(new s["Vector3"](0,0,0));yt.vertices.push(new s["Vector3"](1,0,0));const xt=new Xe["MeshLine"];xt.setGeometry(yt);function Nt(e,t){const n=new Xe["MeshLineMaterial"]({sizeAttenuation:0,color:e,lineWidth:ft,near:t.near,far:t.far,resolution:new s["Vector2"](t.width,t.height),side:s["DoubleSide"]});const a=new s["Mesh"](xt.geometry,n);a.matrixAutoUpdate=false;return a}function Gt(e,t){const n=new s["Geometry"];n.vertices.push(new s["Vector3"](0,0,0));n.vertices.push(new s["Vector3"](1,0,0));const a=new Xe["MeshLine"];a.setGeometry(n,e=>1-e);const r=new Xe["MeshLineMaterial"]({sizeAttenuation:0,color:e,lineWidth:gt,near:t.near,far:t.far,resolution:new s["Vector2"](t.width,t.height),side:s["DoubleSide"]});const i=new s["Mesh"](a.geometry,r);i.matrixAutoUpdate=false;return i}function At(e,t){const n=new s["Matrix4"];const a=(new s["Vector3"]).subVectors(t,e);n.set(a.x,0,0,e.x,a.y,1,0,e.y,a.z,0,1,e.z,0,0,0,1);return n}class _t{constructor(e,t,n){St(e.functionDefinition,t);const a=new Me(Dt(e,n),t);this.parametricSurface=a;this.object3D=a.object3D}willRender(e){this.parametricSurface.willRender(e)}}function Dt(e,t){return{kind:"ParametricSurface",name:e.name,color:e.color,hideLatex:true,functionDefinition:{x:"x",y:"y",z:e.functionDefinition},parameterVariables:[{name:"x",start:-t,stop:t},{name:"y",start:-t,stop:t}],notation:"ijk"}}function St(e,t){const n=x.getVariables(e);const a=we.getVariableNames(t);const s=Object(i["Set"])(["x","y"]);const o=n.subtract(s).subtract(a);if(!o.isEmpty()){const e=o.count()>1;throw new r(`The variable${e?"s":""} `+`${o.toArray()}`+` ${e?"don't":"doesn't"} appear `+`in your list of sliderVariables.\n        That means we have no idea where its value comes from.`)}const u=a.intersect(s);if(!u.isEmpty()){throw new r(`If you're using a Surface Graph, then x and y cannot be used as slider variables.\n      They'd conflict with the x and y that Surface Graphs use! I detected that you have at leat one slider named:\n      ${u.toArray()}`)}}class Ht{constructor(e,t,n,a,r){Vt(e.functionDefinition,t);const i=new s["Group"];const o=5;const u=r;const l=Mt(Ct(-u,u,o),Ct(-u,u,o),Ct(-u,u,o)).map(([e,t,n])=>new s["Vector3"](e,t,n));this.vectors=l.map(r=>{return new ht(Pt(e.functionDefinition,e.color,r),t,n,a)});this.vectors.forEach(e=>i.add(e.object3D));this.object3D=i}willRender(e){this.vectors.forEach(t=>t.willRender(e))}}function Pt(e,t,n){return{kind:"Vector",name:"v",color:t,hideLatex:true,tail:{x:n.x,y:n.y,z:n.z},tip:{x:`${n.x}+${zt(e.x,n)}`,y:`${n.y}+${zt(e.y,n)}`,z:`${n.z}+${zt(e.z,n)}`},notation:"ijk"}}function zt(e,t){if(typeof e=="string"){return y["parse"](e).transform(e=>{if(e.isSymbolNode){switch(e.name){case"x":return y["parse"](t.x.toString());case"y":return y["parse"](t.y.toString());case"z":return y["parse"](t.z.toString());default:return e}}else{return e}}).toString()}else{return e}}function Vt(e,t){const n=i["Set"].union([x.getVariables(e.x),x.getVariables(e.y),x.getVariables(e.z)]);const a=we.getVariableNames(t);const s=Object(i["Set"])(["x","y","z"]);const o=n.subtract(a).subtract(s);if(!o.isEmpty()){const e=o.count()>1;throw new r(`The variable${e?"s":""} `+`${o.toArray()}`+` in your Vector Field ${e?"don't":"doesn't"} appear`+` in your sliders. That means we're not sure what its value is supposed to be.`)}const u=a.intersect(s);if(!u.isEmpty()){throw new r(`If you're using a Vector Field, then x, y, and z cannot be used as slider variables.\n      They'd conflict with the x, y, and z that Vector Fields use! I detected that you have at leat one slider named:\n      ${u.toArray()}`)}}function Ct(e,t,n){const a=(t-e)/(n-1);let r=[];for(let t=0;t<n;t++){r.push(e+t*a)}return Object(i["List"])(r)}function Mt(e,t,n){return e.flatMap(e=>t.flatMap(t=>n.map(n=>{const a=[e,t,n];return a})))}var kt=n(122);class It{constructor(e,t,n){Et(e.position,t);this.object3D=new s["Object3D"];this.calculatePosition=N.compile(e.position);this.labelDiv=document.createElement("div");this.labelDiv.style.position="absolute";this.labelDiv.style.willChange="transform";this.labelDiv.style.transformStyle="preserve-3d";this.labelDiv.style.filter="drop-shadow(white 1px 1px 0.7px)";this.labelDiv.style.fontSize="22px";Object(kt["renderExpressionIntoElement"])(e.label,this.labelDiv);n.appendChild(this.labelDiv)}willRender({spaceConfig:e,scope:t,cameraSettings:n,clipToCssPixels:a}){const r=this.calculatePosition(t);const i=r.multiplyScalar(1/e.scale);const o=(new s["Matrix4"]).premultiply(n.worldToCamera).premultiply(n.cameraToClip).premultiply(a);const u=i.applyMatrix4(o);this.labelDiv.style.transform=`translate3d(${u.x}px, ${u.y}px, ${u.z}px) translate(-50%, -50%)`;this.labelDiv.style.visibility=0<u.z&&u.z<1?"visible":"hidden"}}function Et(e,t){const n=N.getVariables(e);const a=we.getVariableNames(t);const s=n.subtract(a);if(!s.isEmpty()){const e=s.count()>1;throw new r(`The variable${e?"s":""} ${s.toArray()} in your Point definition ${e?"don't":"doesn't"} appear in either sliderVariables. That means we have no idea where its value comes from.`)}}function Ot(e,t,n,a,r,s){switch(e.kind){case"ParametricCurve":return new rt(e,t,a,n);case"ParametricSurface":return new Me(e,t);case"Vector":return new ht(e,t,a,r);case"VectorField":return new Ht(e,t,a,r,n);case"Point":return new ye(e,t);case"Surface":return new _t(e,t,n);case"Implicit":return new Ue(e,t);case"GeometricPrimitive":return new _e(e,t);case"Label":return new It(e,t,s);default:return Ge(e)}}var Lt=n(1771);const Tt=new s["Color"]("#ECEDEF");const Ft=new s["Clock"];class $t{constructor(e,t,n,a){this.camera=a;const r=new s["WebGLRenderer"]({alpha:true,antialias:false});r.setSize(e,t);r.setPixelRatio(window.devicePixelRatio);r.setClearColor(Tt,1);this.effectComposer=new Lt["EffectComposer"](r);this.renderPass=new Lt["RenderPass"](n,a.getThreeCamera());this.renderPass.renderToScreen=true;this.effectComposer.addPass(this.renderPass);this.effectComposer.renderer.domElement.classList.add("android-draggable");this.loadAntiAliasing()}getDomElement(){return this.effectComposer.renderer.domElement}render(){this.effectComposer.render(Ft.getDelta())}getSize(){return this.effectComposer.renderer.getSize()}setSize(e,t){this.effectComposer.setSize(e,t)}loadAntiAliasing(){const e=Ut(Lt["SMAAEffect"].searchImageDataURL);const t=Ut(Lt["SMAAEffect"].areaImageDataURL);Promise.all([e,t]).then(([e,t])=>this.onAntiAliasingImagesLoaded(e,t))}onAntiAliasingImagesLoaded(e,t){const n=new Lt["EffectPass"](this.camera.getThreeCamera(),new Lt["SMAAEffect"](e,t));this.effectComposer.addPass(n);this.renderPass.renderToScreen=false;n.renderToScreen=true}}function Ut(e){const t=new Image;const n=new Promise(e=>t.addEventListener("load",()=>e(t)));t.src=e;return n}const jt=Object(lt["getImageUrl"])("Graph3D/positive-x.png");const Bt=Object(lt["getImageUrl"])("Graph3D/negative-x.png");const Jt=Object(lt["getImageUrl"])("Graph3D/positive-y.png");const Wt=Object(lt["getImageUrl"])("Graph3D/negative-y.png");const qt=Object(lt["getImageUrl"])("Graph3D/positive-z.png");const Yt=Object(lt["getImageUrl"])("Graph3D/negative-z.png");const Xt=8;const Zt=new s["Color"](.2,.2,.2);class Qt{constructor(e,t,n){const a=new s["Group"];this.axes=[];if(e.includes("x")){const e=new Kt("x",t,n);a.add(e.object3D);this.axes.push(e)}if(e.includes("y")){const e=new Kt("y",t,n);a.add(e.object3D);this.axes.push(e)}if(e.includes("z")){const e=new Kt("z",t,n);a.add(e.object3D);this.axes.push(e)}this.object3D=a}willRender(e){for(const t of this.axes){t.willRender(e)}}}class Kt{constructor(e,t,n){const a=new s["Group"];a.add(nn(t));this.tickDiscs=an();a.add(...this.tickDiscs);[this.positiveLabel,this.negativeLabel]=en(e,n);a.add(this.positiveLabel,this.negativeLabel);switch(e){case"x":break;case"y":a.rotateZ(s["Math"].degToRad(90));break;case"z":a.rotateY(s["Math"].degToRad(-90));break}this.object3D=a}willRender({cameraSettings:e}){this.positiveLabel.position.copy(new s["Vector3"](1.1,0,0));this.negativeLabel.position.copy(new s["Vector3"](-1.1,0,0));this.tickDiscs.forEach(t=>cn(t,e.position))}}function en(e,t){switch(e){case"x":return[tn(jt,t),tn(Bt,t)];case"y":return[tn(Jt,t),tn(Wt,t)];case"z":return[tn(qt,t),tn(Yt,t)]}}function tn(e,t){const n=new s["Geometry"];n.vertices.push(new s["Vector3"](0,0,0));const a=ut(e,t);const r=new s["SpriteMaterial"]({map:a,transparent:true,sizeAttenuation:false,depthWrite:false});const i=new s["Sprite"](r);i.scale.set(.05,.05,1);return i}function nn(e){const t=new s["Geometry"];t.vertices.push(new s["Vector3"](-1,0,0));t.vertices.push(new s["Vector3"](1,0,0));const n=new Xe["MeshLine"];n.setGeometry(t);const a=new Xe["MeshLineMaterial"]({sizeAttenuation:0,color:Zt,lineWidth:Xt,near:e.near,far:e.far,resolution:new s["Vector2"](e.width,e.height),side:s["DoubleSide"]});return new s["Mesh"](n.geometry,a)}function an(){const e=5;const t=1;let n=[];for(let a=0;a<e;a++){const r=t*(a/e);const s=ln(r);const i=ln(-r);n.push(s,i)}return n}const rn=.03;const sn=.01;const on=new s["CylinderGeometry"](rn,rn,sn,16);const un=new s["MeshBasicMaterial"]({color:Zt});function ln(e){const t=new s["Mesh"](on,un);t.position.setX(e);t.rotateZ(s["Math"].degToRad(90));return t}function cn(e,t){const n=e.position.distanceTo(t);const a=1/4;const r=2;const s=Math.min(r,n*a);e.scale.setScalar(s)}class dn{constructor(e,t,n,a,r,o){this.spaceConfig=t;this.onRenderNeeded=o;const u=this.spaceConfig.cameraPosition||{polarAngle:40,azimuthAngle:20,radius:3};this.camera=new z({aspectRatio:a/r,focusPoint:this.spaceConfig.focusPoint,position:vn(u)});const l={width:a,height:r,near:z.nearPlane,far:z.farPlane};const c=new Qt(t.showAxes,l,o);const d=new s["Scene"];d.add(L());this.renderer=new $t(a,r,d,this.camera);this.domElement=document.createElement("div");const v=document.createElement("div");const m=this.renderer.getDomElement();this.domElement.appendChild(v);this.domElement.appendChild(m);v.style.overflow="hidden";v.style.position="absolute";v.style.top="0";v.style.bottom="0";v.style.left="0";v.style.right="0";v.style.pointerEvents="none";this.domElement.style.position="relative";this.components=Object(i["List"])(e.map(e=>{return Ot(e,n,this.spaceConfig.scale,l,o,v)})).push(c);this.components.forEach(e=>d.add(e.object3D));this.camera.setUpOrbitControls(this.domElement,this.onRenderNeeded)}render(e){this.camera.positionCamera(e);const{width:t,height:n}=this.renderer.getSize();const a=(new s["Matrix4"]).makeScale(1,-1,1).premultiply((new s["Matrix4"]).makeTranslation(1,1,1)).premultiply((new s["Matrix4"]).makeScale(.5*t,.5*n,.5));this.components.forEach(t=>t.willRender({cameraSettings:this.camera.getRenderInfo(),spaceConfig:this.spaceConfig,scope:e,clipToCssPixels:a}));this.renderer.render()}setSize(e,t){this.renderer.setSize(e,t);this.onRenderNeeded()}getCameraPosition(e){if(e==="root.spaceConfig.cameraPosition"){return mn(this.camera.getPosition())}}}function vn(e){const t=Math.PI/180;return new s["Spherical"](e.radius,e.polarAngle*t,e.azimuthAngle*t)}function mn(e){const t=180/Math.PI;return{radius:e.radius,polarAngle:e.phi*t,azimuthAngle:e.theta*t}}let fn=Object(i["Map"])();function gn(e){e.forEach(e=>{const t=u(e.color);fn=fn.set(e.name,t)})}function hn(e){const t=u(e.color);switch(e.kind){case"Surface":return`${wn(e.name,t)}(x,y) = ${bn(e.functionDefinition)}`;case"Point":return`${wn(e.name,t)}=\n          ${An(e.position)}`;case"Vector":const n=wn(Rn(e.name),t);if(e.notation=="tail-to-tip"){return`${n}:\n            \\text{tail}=${An(e.tail)}, \n            \\text{tip}=${An(e.tip)}\n          `}else{const t={x:`${e.tip.x} - (${e.tail.x})`,y:`${e.tip.y} - (${e.tail.y})`,z:`${e.tip.z} - (${e.tail.z})`};return`${n}=\n          ${_n(t,e.notation,true)}`}case"ParametricSurface":return`${wn(Rn(e.name),t)}(${e.parameterVariables[0].name}, ${e.parameterVariables[1].name})=\n          ${_n(e.functionDefinition,e.notation)}`;case"ParametricCurve":return`${wn(Rn(e.name),t)}(${e.parameterVariable.name})=\n        ${_n(e.functionDefinition,e.notation)}`;case"VectorField":return`${wn(Rn(e.name),t)}(x,y,z)=${_n(e.functionDefinition,e.notation)}`;case"Implicit":return"I'll get to this";case"GeometricPrimitive":return null;case"Label":return null;default:return Ge(e)}}function pn(e){if(e.type=="SymbolNode"&&e.name){const t=fn.get(e.name);if(t){return wn(e.toTex(),t)}}}function bn(e){return y["parse"](e.toString()).toTex({handler:pn})}function wn(e,t){return`{\\color{#${t.getHexString()}}${e}}`}function Rn(e){return`\\overrightarrow{${e}}`}function yn(e){return`\\begin{bmatrix} \n    ${bn(e.x)} \\\\\n    ${bn(e.y)} \\\\\n    ${bn(e.z)} \\\\\n    \\end{bmatrix} `}function xn(e){return`\n    \\left[${bn(e.x)}\\right]\\mathbf{\\hat{i}} +\n    \\left[${bn(e.y)}\\right]\\mathbf{\\hat{j}} +\n    \\left[${bn(e.z)}\\right]\\mathbf{\\hat{k}}\n`}function Nn(e){return`\n    \\begin{align}\n    \\left[${bn(e.x)}\\right]&\\mathbf{\\hat{i}} + \\\\ \n    \\left[${bn(e.y)}\\right]&\\mathbf{\\hat{j}} + \\\\ \n    \\left[${bn(e.z)}\\right]&\\mathbf{\\hat{k}}\n    \\end{align}\n`}function Gn(e){return`\\left\\langle\n    ${bn(e.x)},\n    ${bn(e.y)},\n    ${bn(e.z)} \n    \\right\\rangle`}function An(e){return`\\left(\n    ${bn(e.x)},\n    ${bn(e.y)},\n    ${bn(e.z)} \n    \\right)`}function _n(e,t,n){let a=Object.assign({},e);if(n){a.x=x.simplify(a.x);a.y=x.simplify(a.y);a.z=x.simplify(a.z)}switch(t){case"angle-brackets":return Gn(a);case"ijk":return xn(a);case"ijk-multiline":return Nn(a);case"column":return yn(a);default:return Ge(t)}}const Dn=320/250;const Sn=500;const Hn=Sn/Dn;class Pn{constructor(e,t,n){this.container=t;this.animationFrameRequest=null;m();f(e);const a=Object(i["List"])(e.components.map(g));const r=Object(i["List"])(e.sliderVariables.map(g));const s=Math.min(Sn,this.container.offsetWidth);const o=s/Dn;try{Vn(a);Cn(r);Mn(r);this.scope=we.initializeFromSliderVariables(r);this.portal=new dn(a,e.spaceConfig,this.scope,s,o,this.renderPortal.bind(this))}catch(e){if(e.kind=="ConfigurationError"){zn(e,t)}throw e}gn(r);const u=Object(i["List"])(a.filter(e=>e.hideLatex!=true).map(e=>hn(e)).filter(e=>e!==null));w(Sn,Hn,r,u,this.handleSliderChange.bind(this),n,t,this.portal.domElement);this.setupResizeListener();this.renderPortal()}handleSliderChange(e,t){this.scope=this.scope.set(e,t);this.renderPortal()}renderPortal(){if(this.animationFrameRequest){cancelAnimationFrame(this.animationFrameRequest)}this.animationFrameRequest=requestAnimationFrame(()=>{this.portal.render(this.scope);this.animationFrameRequest=null})}setupResizeListener(){window.addEventListener("resize",()=>{const e=Math.min(Sn,this.container.offsetWidth);const t=e/Dn;this.portal.setSize(e,t)})}getConfigValue(e){return Object(a["a"])(this,void 0,void 0,(function*(){if(e==="root.spaceConfig.cameraPosition"){return this.portal.getCameraPosition(e)}else{throw new Error(`We haven't implemented pulling ${e} yet.`)}}))}}function zn(e,t){t.innerHTML="";const n=document.createElement("div");n.innerText=`We detected an error with your Escher configuration:\n      ${e.message}`;t.appendChild(n)}function Vn(e){let t=Object(i["Map"])();e.forEach(e=>{const n=e.name;const a=t.get(n);if(a!=undefined){throw new r(`You have a duplicate name in your configuration.\n        Specifically, both a ${e.kind} and a `+` ${a.kind} share the name "${n}".`)}else{t=t.set(n,e)}})}function Cn(e){const t=Object(i["List"])(e.map(e=>e.name));const n=t.countBy(e=>e);const a=n.filter((e,t)=>e>=2);if(a.size>0){throw new r(`\n            You can't have multiple sliders with the same name. Right now, ${a.keySeq().toArray()} all appear at least twice.\n        `)}}function Mn(e){const t=Object(i["Set"])(e.map(e=>e.name));const n=Object(i["Set"])(Object(i["Map"])(B).keys());const a=t.intersect(n);if(!a.isEmpty()){throw new r(`\n      You've used a reserved name for your slider! Specifically, you used ${a.toArray()}.\n      The full list of reserved names is: ${n.toArray()}\n    `)}}var kn=n(12);var In=n(3);var En=t["default"]={createInteractive:e=>{const t=document.getElementById(e.visualizationKey);if(t){t.innerHTML="";const n=e.authoredData;const a=new Pn(n,t,e.slug);In["$window"].on(kn["EVT_DAILYPROBLEM_MAINBODY_EXPANDED"],()=>{a.renderPortal();In["$window"].off(kn["EVT_DAILYPROBLEM_MAINBODY_EXPANDED"])});In["$window"].on(kn["EVT_QUIZ_POSITION_DID_CHANGE"],()=>{a.renderPortal()});return a}},createInteractiveSolvable:()=>{throw new Error("Interactive solvables not supported for 3D graphs")}}}}]);
//# sourceMappingURL=viz-02-escher.4e4330dac87ca908b5ad.js.map